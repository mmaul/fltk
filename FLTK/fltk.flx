requires package "fltk";
include "FLTK/fltk_enumerations";
open C_hack;
// *****************Type Declarations****************
// **                                              ** 
type fl_image = "Fl_Image *";
type fl_rgb_image = "Fl_RGB_Image *";
type fl_shared_image = "Fl_Shared_Image *";
type fl_shared_image_handler = "Fl_Shared_Image_handler";
type fl_pnm_image = "Fl_PNM_Image *";

type fl_window = "Fl_Window *";
type fl_double_window = "Fl_Double_Window *";
type fl_widget = "Fl_Widget *";
type fl_box = "Fl_Box *";
//type fl_boxtype = "Fl_Boxtype *";
type fl_group = "Fl_Group *";
type fl_button = "Fl_Button *";
type fl_check_button = "Fl_Check_Button *";
type fl_light_button = "Fl_Light_Button *";
type fl_radio_button = "Fl_Radio_Button *";
type fl_radio_light_button = "Fl_Radio_Light_Button *";
type fl_radio_round_button = "Fl_Radio_Round_Button *";
type fl_repeat_button = "Fl_Repeat_Button *";
type fl_return_button = "Fl_Return_Button *";
type fl_round_button = "Fl_Round_Button *";
cstruct Fl_Menu_Item {
    text:       +char; 	      ///< menu item text, returned by label()
    shortcut_:  int;          ///< menu item shortcut
    callback_:    Fl_Callback;///< menu item callback
    user_data_:   address;    ///< menu item user_data for the menu's callback
    flags:        int;	      ///< menu item flags like FL_MENU_TOGGLE
    labeltype_:   utiny;      ///< how the menu item text looks like
    labelfont_:  Fl_Font;    ///< which font for this menu item text
    labelsize_:   Fl_Fontsize;///< size of menu item text
    labelcolor_: Fl_Color;   ///< menu item text color
  };
typedef fl_menu_item = &Fl_Menu_Item;
type fl_menu_ = "Fl_Menu_ *";
type fl_menu_bar = "Fl_Menu_Bar *";
type fl_menu_button = "Fl_Menu_Button *";
type fl_toggle_button = "Fl_Toggle_Button *";
type fl_choice = "Fl_Choice *";
type fl_input_ = "Fl_Input_ *";
type fl_input = "Fl_Input *";
type fl_int_input = "Fl_Int_Input *";
type fl_float_input = "Fl_Float_Input *";
type fl_secret_input = "Fl_Secret_Input *";
type fl_multiline_input = "Fl_Multiline_Input *";
type fl_color_chooser = "Fl_Color_Chooser *";
type fl_file_icon = "Fl_File_Icon *";
type fl_file_chooser = "Fl_File_Chooser *";
type fl_native_file_chooser = "Fl_Native_File_Chooser";
type fl_text_editor = "Fl_Text_Editor *";
type fl_text_display = "Fl_Text_Display *";
type fl_valuator = "Fl_Valuator *";
type fl_slider = "Fl_Slider *";
type fl_hor_slider = "Fl_Hor_Slider *";
type fl_gl_window = "Fl_Gl_Window *";// requires fl_gl;
type fl_gl_window_proxy = "Fl_Gl_Window_Proxy *";// requires fl_gl;

typedef Fl_Region = address;
typedef fl_region = Fl_Region;
typedef Fl_Sliders = typesetof(
  fl_slider,
  fl_hor_slider
);

typedef Fl_Valuators = typesetof(
  fl_valuator,
  Fl_Sliders
);

typedef Fl_Images = typesetof(
  fl_image,
  fl_rgb_image,
  fl_shared_image,
  fl_pnm_image
);

typedef Fl_RGB_Images = typesetof(
  fl_rgb_image
);


typedef Fl_Groups = typesetof(
  fl_group,
  fl_color_chooser,
  Fl_Windows,
  fl_text_display
);

typedef Fl_Buttons = typesetof(
  fl_button,
  fl_check_button,
  fl_light_button,
  fl_radio_button,
  fl_radio_light_button,
  fl_radio_round_button,
  fl_repeat_button,
  fl_return_button,
  fl_round_button,
  fl_toggle_button
);

typedef Fl_Gl_Windows = typesetof(
  fl_gl_window,
  fl_gl_window_proxy
);

typedef Fl_Windows = typesetof(
  fl_window,
  fl_double_window,
  Fl_Gl_Windows
);

typedef Fl_Menus = typesetof(
  fl_menu_,
  fl_menu_bar,
  fl_menu_button,
  fl_choice
);

typedef Fl_Menu_Items = typesetof(
  fl_menu_item,
  fl_menu_bar
);

typedef Fl_Inputs = typesetof(
  fl_input_,
  Fl_Input_Specializations
);

typedef Fl_Input_Specializations = typesetof(
  fl_input,
  fl_int_input,
  fl_secret_input,
  fl_float_input,
  fl_multiline_input
);

typedef Fl_Widgets = typesetof(
  fl_widget,
  fl_box,
  Fl_Groups,
  Fl_Buttons,
  Fl_Windows,
  Fl_Menus,
  fl_input_,
  Fl_Inputs,
  Fl_Input_Specializations,
  Fl_Valuators
); 

typedef Fl_CXX_Classes = typesetof(
  fl_widget,
  fl_box,
  Fl_Groups,
  Fl_Buttons,
  Fl_Menus,
  fl_input_,
  Fl_Inputs,
  Fl_Input_Specializations,
  fl_menu_item
);

typedef Fl_C_CXX_PTRS = typesetof(
  Fl_CXX_Classes,
  &fl_menu_item
);

typedef Fl_Text_Displays = typesetof(
  fl_text_display,
  fl_text_editor
);

typedef Fl_Callback = fl_widget*address --> void;
typedef fl_callback = Fl_Callback;
typedef Fl_Callback0 = fl_widget --> void;
typedef fl_callback0 = Fl_Callback0;
typedef Fl_Callback1 = fl_widget*long --> void;
typedef fl_callback1 =fl_callback1;
typedef Fl_FileChooserCallback = fl_file_chooser*address --> void;
typedef fl_char = uint;
cproc emptycb(widget:fl_widget, data:address) {}
callback proc fl_callback_cb: fl_widget * fl_callback_cb;
header """
void fl_callback_cb  (Fl_Widget *w, void *client_data) {
        Fl_Callback *p = (Fl_Callback *)client_data;
        p(w,(void *)0);
}
""";

callback proc fl_callback_proxy: fl_callback_proxy;
typedef c_handler_t = address --> void;
typedef f_handler_t = 1->void;

callback fun fl_callback_proxy1: int*fl_callback_proxy1->int;
typedef c_handler1_t = int*address --> int;
typedef f_handler1_t = int->int;

//$ A pointer to the class instance or container thereof should be stored 
//$ in first parameter.This is necessary if callback needs to access 
//$ the specific instance of the class that invoked it
callback proc fl_callback_proxy2: address*fl_callback_proxy2;
typedef c_handler2_t = address*address --> void;
typedef f_handler2_t = address->void;

//$ A pointer to the class instance or container thereof should be stored 
//$ in first parameter.This is necessary if callback needs to access 
//$ the specific instance of the class that invoked it
callback fun fl_callback_proxy3: address*int*fl_callback_proxy3->int;
typedef c_handler3_t = address*int*address --> int;
typedef f_handler3_t = address*int->int;

header wtf =   """
typedef void (Fl_Callback_Proxy )(void*);
typedef int (Fl_Callback_Proxy1 )(int,void*);
typedef void (Fl_Callback_Proxy2 )(void*,void*);
typedef int (Fl_Callback_Proxy3 )(void*,int,void*);

""";
requires wtf;
//requires fl_callback_proxy_header;
// ***************** Implementations ****************
// **                                              ** 
/** \defgroup  callback_functions Callback function typedefs
 \brief Typedefs defined in <FL/Fl.H> for callback or handler functions passed as function parameters.

    FLTK uses callback functions as parameters for some function calls, e.g. to
    set up global event handlers (Fl::add_handler()), to add a timeout handler
    (Fl::add_timeout()), and many more.

    The typedefs defined in this group describe the function parameters used to set
    up or clear the callback functions and should also be referenced to define the
    callback function to handle such events in the user's code.

    \see Fl::add_handler(), Fl::add_timeout(), Fl::repeat_timeout(),
	 Fl::remove_timeout() and others
  @{ */

/** Signature of some label drawing functions passed as parameters */

// Signature of add_handler functions passed as parameters */
typedef fl_event_handler = int-->int;
typedef fl_event_dispatch = int*fl_window-->int;
typedef fl_label_draw_f = fl_label*int*int*int*int*int*int*fl_align*fl_align-->void;
typedef fl_label_measure_f = fl_label*&int*&int--> void;
typedef fl_box_draw_f = int*int*int*int*fl_color-->void;

/** Signature of some timeout callback functions passed as parameters */
typedef fl_timeout_handler = address-->void;

/** Signature of some wakeup callback functions passed as parameters */
typedef fl_awake_handler = address--void;

/** Signature of add_idle callback functions passed as parameters */
typedef fl_idle_handler = address-->void;

/** Signature of set_idle callback functions passed as parameters */
typedef fl_old_idle_handler = void-->void;

/** Signature of add_fd functions passed as parameters */
typedef fl_fd_handler = int*address-->void;

/** Signature of set_abort functions passed as parameters */
typedef fl_abort_handler = carray[char]-->void;

/** Signature of set_atclose functions passed as parameters */
typedef fl_atclose_handler = fl_window*address-->void;

/** Signature of args functions passed as parameters */
typedef fl_args_handler = int*carray[char]*&int-->void;

fun isNULL[T in Fl_C_CXX_PTRS] :T->bool = "($1==0)";

open class Fl_Common[T in Fl_CXX_Classes] {
  fun handle:T*int->int = "$1->handle($2)";
  proc delete: T = "delete $1;";
}

class Fl {

  fun wait: 1->int = "Fl::wait()";
  fun wait: double->double = "Fl::wait($1)";
  fun check: 1->int = "Fl::check()";
  fun ready: 1->int = "Fl::ready()";
  proc run:1 = "::Fl::run();";


@h2
   event information:
  
    Returns the last event that was processed. This can be used
    to determine if a callback is being done in response to a
    keypress, mouse click, etc.
@felix 
  fun event: 1->int = "Fl::event()";

  //$  Returns the mouse position of the event relative to the Fl_Window
  //$  it was passed to.

  fun event_x: 1->int = "Fl::event_x()";
  
  //$  Returns the mouse position of the event relative to the Fl_Window
  //$  it was passed to.
  
  fun event_y: 1->int = "Fl::event_y()";
  
  //$  Returns the mouse position on the screen of the event.  To find the
  //$  absolute position of an Fl_Window on the screen, use the
  //$  difference between event_x_root(),event_y_root() and 
  //$  event_x(),event_y().
  
  fun event_x_root: 1->int = "Fl::event_x_root()";
  
  //$  Returns the mouse position on the screen of the event.  To find the
  //$  absolute position of an Fl_Window on the screen, use the
  //$  difference between event_x_root(),event_y_root() and 
  //$  event_x(),event_y().
  
  fun event_y_root: 1->int = "Fl::event_y_root()";
  
  //$  Returns the current horizontal mouse scrolling associated with the
  //$  FL_MOUSEWHEEL event. Right is positive.
  
  fun event_dx: 1->int = "Fl::event_dx()";
  
  //$  Returns the current vertical mouse scrolling associated with the
  //$  FL_MOUSEWHEEL event. Down is positive.
  
  fun event_dy: 1->int = "Fl::event_dy()";
  
  //$  Return where the mouse is on the screen by doing a round-trip query to
  //$  the server.  You should use Fl::event_x_root() and 
  //$  Fl::event_y_root() if possible, but this is necessary if you are
  //$  not sure if a mouse event has been processed recently (such as to
  //$  position your first window).  If the display is not open, this will
  //$  open it.
  
  proc get_mouse: &int*&int = "Fl::get_mouse($1,$2);"; // platform dependent
  
  //$  Returns non zero if we had a double click event.
  //$  \retval Non-zero if the most recent FL_PUSH or FL_KEYBOARD was a "double click".  
  //$  \retval  N-1 for  N clicks. 
  //$  A double click is counted if the same button is pressed
  //$  again while event_is_click() is true.

  fun get_event_clicks: 1->int = "Fl::event_clicks()";

  //$  Manually sets the number returned by Fl::event_clicks().  
  //$  This can be used to set it to zero so that
  //$  later code does not think an item was double-clicked.
  //$  \param[in] i corresponds to no double-click if 0, i+1 mouse clicks otherwise
  //$  \see int event_clicks()
  
  proc event_clicks: int = "Fl::event_clicks($1);";
  
  //$  Returns non-zero if the mouse has not moved far enough
  //$  and not enough time has passed since the last FL_PUSH or 
  //$  FL_KEYBOARD event for it to be considered a "drag" rather than a
  //$  "click".  You can test this on FL_DRAG, FL_RELEASE,
  //$  and FL_MOVE events.  
  
  fun get_event_is_click: 1->int = "Fl::event_is_click()";
  
  //$  Clears the value returned by Fl::event_is_click().  
  //$  Useful to prevent the <I>next</I>
  //$  click from being counted as a double-click or to make a popup menu
  //$  pick an item with a single click.  Don't pass non-zero to this. 
  
  proc event_is_click: int = "Fl::event_is_click($1);";
  
  //$  Gets which particular mouse button caused the current event. 
  //$  This returns garbage if the most recent event was not a FL_PUSH or FL_RELEASE event.
  //$  \retval FL_LEFT_MOUSE \retval FL_MIDDLE_MOUSE \retval FL_RIGHT_MOUSE.
  //$  \see Fl::event_buttons()
  
  fun event_button: 1->int = "Fl::event_button()";
  
@h2  This is a bitfield of what shift states were on and what mouse buttons
     were held down during the most recent event. The second version
     returns non-zero if any of the passed bits are turned on.
     The legal bits are:
    
     \li FL_SHIFT
     \li FL_CAPS_LOCK
     \li FL_CTRL
     \li FL_ALT
     \li FL_NUM_LOCK
     \li FL_META
     \li FL_SCROLL_LOCK
     \li FL_BUTTON1
     \li FL_BUTTON2
     \li FL_BUTTON3
    
     X servers do not agree on shift states, and FL_NUM_LOCK, FL_META, and
     FL_SCROLL_LOCK may not work. The values were selected to match the
     XFree86 server on Linux. In addition there is a bug in the way X works
     so that the shift state is not correctly reported until the first event
     <I>after</I> the shift key is pressed or released.
@felix
  fun event_state: 1->int ="Fl::event_state()";
  //$ See int event_state() */

  fun event_state: int->int = "Fl::event_state($1)";
  
@h2 Gets which key on the keyboard was last pushed.

    The returned integer 'key code' is not necessarily a text
    equivalent for the keystroke. For instance: if someone presses '5' on the 
    numeric keypad with numlock on, Fl::event_key() may return the 'key code'
    for this key, and NOT the character '5'. To always get the '5', use Fl::event_text() instead.
    
    \returns an integer 'key code', or 0 if the last event was not a key press or release.
    \see int event_key(int), event_text(), compo
se(int&).
@felix
  fun event_key: 1->int ="Fl::event_key()";
@h2
    Returns the keycode of the last key event, regardless of the NumLock state.
      
    If NumLock is deactivated, FLTK translates events from the 
    numeric keypad into the corresponding arrow key events. 
    event_key() returns the translated key code, whereas
    event_original_key() returns the keycode before NumLock translation.
@felix
  fun event_original_key: 1->int = "Fl::event_original_key()";
@h2
    Returns true if the given \p key was held
    down (or pressed) <I>during</I> the last event.  This is constant until
    the next event is read from the server.
    
    Fl::get_key(int) returns true if the given key is held down <I>now</I>.
    Under X this requires a round-trip to the server and is <I>much</I>
    slower than Fl::event_key(int).
    
    Keys are identified by the <I>unshifted</I> values. FLTK defines a
    set of symbols that should work on most modern machines for every key
    on the keyboard:
    
    \li All keys on the main keyboard producing a printable ASCII
	character use the value of that ASCII character (as though shift,
	ctrl, and caps lock were not on). The space bar is 32.
    \li All keys on the numeric keypad producing a printable ASCII
	character use the value of that ASCII character plus FL_KP.
	The highest possible value is FL_KP_Last so you can
	range-check to see if something is  on the keypad.
    \li All numbered function keys use the number on the function key plus 
	FL_F.  The highest possible number is FL_F_Last, so you
	can range-check a value.
    \li Buttons on the mouse are considered keys, and use the button
	number (where the left button is 1) plus FL_Button.
    \li All other keys on the keypad have a symbol: FL_Escape,
	FL_BackSpace, FL_Tab, FL_Enter, FL_Print, FL_Scroll_Lock, FL_Pause,
	FL_Insert, FL_Home, FL_Page_Up, FL_Delete, FL_End, FL_Page_Down,
	FL_Left, FL_Up, FL_Right, FL_Down, FL_Shift_L, FL_Shift_R,
	FL_Control_L, FL_Control_R, FL_Caps_Lock, FL_Alt_L, FL_Alt_R,
	FL_Meta_L, FL_Meta_R, FL_Menu, FL_Num_Lock, FL_KP_Enter.  Be
	careful not to confuse these with the very similar, but all-caps,
	symbols used by Fl::event_state().

    On X Fl::get_key(FL_Button+n) does not work.
    
    On WIN32 Fl::get_key(FL_KP_Enter) and Fl::event_key(FL_KP_Enter) do not work.
@felix
  fun event_key: int->int = "Fl::event_key($1);";
  
  //$  Returns true if the given \p key is held down <I>now</I>.  
  //$  Under X this requires a round-trip to the server and is <I>much</I>
  //$  slower than Fl::event_key(int). \see event_key(int)
  
  fun get_key: int->int = "Fl::get_key($1)"; // platform dependent

@h2
    Returns the text associated with the current event, including FL_PASTE or FL_DND_RELEASE events.
    This can be used in response to FL_KEYUP, FL_KEYDOWN, FL_PASTE, FL_DND_RELEASE.

    When responding to FL_KEYUP/FL_KEYDOWN, use this function instead of Fl::event_key()
    to get the text equivalent of keystrokes suitable for inserting into strings 
    and text widgets.

    The returned string is guaranteed to be be NULL terminated.
    However, see Fl::event_length() for the actual length of the string,
    in case the string itself contains NULLs that are part of the text data.

    \returns A NULL terminated text string equivalent of the last keystroke.
@felix
  fun event_text: 1->string = "Fl::event_text()";

 //$   Returns the length of the text in Fl::event_text(). There
 //$   will always be a nul at this position in the text. However there may
 //$   be a nul before that if the keystroke translates to a nul character or
 //$   you paste a nul character.

  fun event_length: 1->int = "Fl::event_length()";

  gen compose: &int->int = "Fl::compose($1)";
  proc compose_reset: 1 = "Fl::compose_reset();";
  fun event_inside: int*int*int->int = "Fl::event_inside($1,$2,$3)";
  fun event_inside: fl_widget->int = "Fl::event_inside(const_cast<Fl_Widget *>($1))";

  //$  Gets the widget that is below the mouse. 
  //$     \see  belowmouse(Fl_Widget*) */
  fun get_belowmouse: 1->fl_widget = "Fl::belowmouse()";
  proc belowmouse: fl_widget ="Fl::belowmouse($1);";
  //$ Gets the widget that is being pushed.
  //$    \see void pushed(Fl_Widget*) */
  fun get_pushed: 1->fl_widget ="Fl::pushed()";
  proc pushed: fl_widget = "Fl::pushed($1);";
  //$ Gets the current Fl::focus() widget. \sa Fl::focus(Fl_Widget*) */
  fun focus: 1->fl_widget = "Fl::focus()";
  proc focus: fl_widget = "Fl::focus($1);";
  proc add_handler: fl_event_handler = "Fl::add_handler($1);";
  proc remove_handler: fl_event_handler = "Fl::remove_handler($1);";
  proc event_dispatch:fl_event_dispatch = "Fl::event_dispatch($1);";
  fun get_event_dispatch: 1->fl_event_dispatch = "Fl::event_dispatch()";

  //$ \defgroup  fl_clipboard  Selection & Clipboard functions
  //$ FLTK global copy/cut/paste functions declared in <FL/Fl.H>

@h3   cut/paste:
  
  Copies the data pointed to by \p stuff to the selection buffer 
  (\p destination is 0) or
  the clipboard (\p destination is 1); \p len is the number of relevant
  bytes in \p stuff.
  The selection buffer is used for
  middle-mouse pastes and for drag-and-drop selections. The 
  clipboard is used for traditional copy/cut/paste operations.
  */
  proc copy: string*int*int = "Fl::copy(const_cast<char *>(strdup($1.c_str()),$1,$2);";
  proc copy: string*int*int = "Fl::copy(const_cast<char *>(strdup($1.c_str()),$1);";

@h3
  Pastes the data from the selection buffer (\p source is 0) or the clipboard 
  (\p source is 1) into \p receiver.  
  Set things up so the receiver widget will be called with an FL_PASTE event some
  time in the future with the data from the specified \p source in Fl::event_text()
  and the number of characters in Fl::event_length().
  The receiver
  should be prepared to be called \e directly by this, or for
  it to happen \e later, or possibly <i>not at all</i>.  This
  allows the window system to take as long as necessary to retrieve
  the paste buffer (or even to screw up completely) without complex
  and error-prone synchronization code in FLTK.
   
  The selection buffer is used for middle-mouse pastes and for 
  drag-and-drop selections. The clipboard is used for traditional 
  copy/cut/paste operations.
  Args: Fl_Widget &receiver, int source /*=0*/);
@felix
  proc paste: fl_widget*int = "Fl::paste($1,$2);";

  //$  Initiate a Drag And Drop operation. The selection buffer should be
  //$  filled with relevant data before calling this method. FLTK will
  //$  then initiate the system wide drag and drop handling. Dropped data
  //$  will be marked as <i>text</i>.
  //$  Create a selection first using:
  //$  Args: const char *stuff, int len, 0)
  
  fun dnd: 1->int = "Fl::dnd()"; // platform dependent


  //$ \defgroup  fl_screen  Screen functions
  //$	fl global screen functions declared in <FL/Fl.H>

  //$ screen size:
  //$ Returns the origin of the current screen work area, where 0 indicates the left side of the screen. */
  fun x:1->int ="Fl::x()"; // platform dependent
  //$ Returns the origin of the current screen work area, where 0 indicates the top edge of the screen. */
  fun y: 1->int = "Fl::y()";
  //$ Returns the width of the screen work area in pixels. */
  fun w: 1->int = "Fl::w()";
  //$ Returns the height of the screen work area in pixels. */
  fun h: 1->int = "Fl::h()";

  // multi-head support:
  fun screen_count: 1->int = "Fl::screen_count()";

  //$    Gets the bounding box of a screen that contains the mouse pointer.
  //$    \param[out]  X,Y,W,H the corresponding screen bounding box
  //$    \see void screen_xywh(int &x, int &y, int &w, int &h, int mx, int my) 
  proc screen_xywh: &int*&int*&int*&int*&int*&int = "Fl::screen_xywh($1,$2,$3,$4,$5,$6);";
  proc screen_xywh: &int*&int*&int*&int*&int*&int*int*int = "Fl::screen_xywh($1,$2,$3,$4,$5,$6,$7,$8);";
  proc screen_xywh: &int*&int*&int*&int*&int*&int*int = "Fl::screen_xywh($1,$2,$3,$4,$5,$6,$7);";
  proc screen_xywh: &int*&int*&int*&int*&int*&int*int*int*int*int = "Fl::screen_xywh($1,$2,$3,$4,$5,$6,$7,$8,$9,$10);";

  proc screen_dpi: float*float*float*int = "Fl::screen_dpi($1,$2,$3);";
  proc screen_dpi: float*float*float*int = "Fl::screen_dpi($1,$2);";

  //$ \defgroup  fl_attributes  Color & Font functions
  //$ fl global color, font functions.
  //$ These functions are declared in <FL/Fl.H> or <FL/fl_draw.H>. 
 
  //$ color map:
  proc set_color: fl_color*utiny*utiny*utiny = "FL::set_color($1,$2,$3);";
  
  //$  Sets an entry in the fl_color index table. You can set it to any
  //$  8-bit RGB color. The color is not allocated until fl_color(i) is used.
  
  proc set_color: fl_color*uint = "Fl::set_color($1,$2);";
  fun get_color: fl_color->uint = "Fl::get_color($1)";
  proc get_color: fl_color*&utiny*&utiny*&utiny = "Fl::get_color($1)";
 
  //$  Frees the specified color from the colormap, if applicable.
  //$  If overlay is non-zero then the color is freed from the
  //$  overlay colormap.
  
  proc free_color: fl_color*int = "Fl::free_color($1,$2);";
  proc free_color: fl_color*int = "Fl::free_color($1);";

  // fonts:
  fun get_font: fl_font->char = "Fl::get_font($1)";
@h2  
    Get a human-readable string describing the family of this face.  This
    is useful if you are presenting a choice to the user.  There is no
    guarantee that each face has a different name.  The return value points
    to a static buffer that is overwritten each call.
    
    The integer pointed to by \p attributes (if the pointer is not
    zero) is set to zero, FL_BOLD or FL_ITALIC or 
    FL_BOLD | FL_ITALIC.  To locate a "family" of fonts, search
    forward and back for a set with non-zero attributes, these faces along
    with the face with a zero attribute before them constitute a family.
@felix
  fun get_font_names: fl_font*int->string = "Fl::get_font_name($1,$2)";
  fun get_font_names: fl_font->string = "Fl::get_font_name($1)";
@h3
    Return an array of sizes in \p sizep.  The return value is the
    length of this array.  The sizes are sorted from smallest to largest
    and indicate what sizes can be given to fl_font() that will
    be matched exactly (fl_font() will pick the closest size for
    other sizes).  A zero in the first location of the array indicates a
    scalable font, where any size works, although the array may list sizes
    that work "better" than others.  Warning: the returned array
    points at a static buffer that is overwritten each call.  Under X this
    will open the display.
@felix
  fun get_font_sizes: fl_font*carray[int]->int = "Fl::get_font_sizes($1,$2)";

  proc set_font: fl_font*string = "Fl::set_font($1,const_cast<char *>(strdup($2.c_str())));";
  proc set_font: fl_font*string = "Fl::set_font($1);";
@h2  
    FLTK will open the display, and add every fonts on the server to the
    face table.  It will attempt to put "families" of faces together, so
    that the normal one is first, followed by bold, italic, and bold
    italic.
    
    The optional argument is a string to describe the set of fonts to
    add.  Passing NULL will select only fonts that have the
    ISO8859-1 character set (and are thus usable by normal text).  Passing
    "-*" will select all fonts with any encoding as long as they have
    normal X font names with dashes in them.  Passing "*" will list every
    font that exists (on X this may produce some strange output).  Other
    values may be useful but are system dependent.  With WIN32 NULL
    selects fonts with ISO8859-1 encoding and non-NULL selects
    all fonts.
    
    The return value is how many faces are in the table after this is done.
@felix
  fun set_fonts: string->fl_font = "Fl::set_fonts(const_cast<char *>(strdup($1.c_str())))";
  fun set_fonts: string->fl_font = "Fl::set_fonts()";

 //$  \defgroup  fl_drawings  Drawing functions
 //$  FLTK global graphics and GUI drawing functions.
 //$  These functions are declared in <FL/fl_draw.H>, 
 //$  and in <FL/x.H> for offscreen buffer-related ones.

  // labeltypes:
  proc set_labeltype: fl_labeltype*fl_label_draw_f*fl_label_measure_f = "set_labeltype($1,$2,$3);";
  //$ Sets the functions to call to draw and measure a specific labeltype. */
  proc set_labeltype: fl_labeltype*fl_labeltype  = "set_labeltype($1,$2);";

  // boxtypes:
  fun get_boxtype: fl_boxtype->fl_box_draw_f = "Fl::get_boxtype($1)";
  proc set_boxtype: fl_boxtype*fl_box_draw_f*utiny*utiny*utiny*utiny = "Fl::set_boxtype($1,$2,$3,$4,$5,$6);";
  proc set_boxtype: fl_boxtype*fl_boxtype = "Fl::set_boxtype($1,$2);";
  fun box_dx: fl_boxtype->int = "Fl::box_dx($1)";
  fun box_dy: fl_boxtype->int = "Fl::box_dy($1)";
  fun box_dw: fl_boxtype->int = "Fl::box_dw($1)";
  fun box_dh: fl_boxtype->int = "Fl::box_dh($1)";
  fun draw_box_active: 1->int = "Fl::draw_box_active()";

  proc fatal:string = "::Fl::fatal(const_cast<char *>($1.c_str()));";

  //$  Sets an entry in the fl_color index table. You can set it to any
  //$  8-bit RGB color. The color is not allocated until fl_color(i) is used.
  proc set_color: fl_color*uint = "Fl::set_color($1,$2);";
  proc set_color: fl_color*utiny*utiny*utiny = "Fl::set_color($1,$2,$3,$4);";
  fun get_color: fl_color->uint = "Fl::get_color($1)";
  proc get_color_: fl_color*&utiny*&utiny*&utiny = "Fl::get_color($1,$2,$3,$4);";
//  proc redraw: 1 = "Fl::redraw();";
//  fun get_color_tuple(i:fl_color) = {
//    var r=0ut; var g=0ut; var b=0ut;
//    Fl::get_color_(i,r,g,b);
//    return r,g,b;
//  }
    cenum Fl_Option = 
      //$ When switched on, moving the text cursor beyond the start or end of
      //$ a text in a text widget will change focus to the next text widget.
      //$ When switched off, the cursor will stop at the end of the text.
      //$ Pressing Tab or Ctrl-Tab will advance the keyboard focus.
    OPTION_ARROW_FOCUS,
      // When switched on, FLTK will use the file chooser dialog that comes 
      // with your operating system whenever possible. When switched off, FLTK
      // will present its own file chooser.
      // \todo implement me
    // OPTION_NATIVE_FILECHOOSER,
      // When Filechooser Preview is enabled, the FLTK or native file chooser
      // will show a preview of a selected file (if possible) before the user
      // decides to choose the file.
      // \todo implement me
    //OPTION_FILECHOOSER_PREVIEW,
      /// If visible focus is switched on, FLTK will draw a dotted rectangle 
      /// inside the widget that will receive the next keystroke. If switched
      /// off, no such indicator will be drawn and keyboard navigation
      /// is disabled.
    OPTION_VISIBLE_FOCUS,
      /// If text drag-and-drop is enabled, the user can select and drag text
      /// from any text widget. If disabled, no dragging is possible, however
      /// dropping text from other applications still works.
    OPTION_DND_TEXT,
      /// If tooltips are enabled, hovering the mouse over a widget with a 
      /// tooltip text will open a little tooltip window until the mouse leaves
      /// the widget. If disabled, no tooltip is shown.
    OPTION_SHOW_TOOLTIPS,
      // don't change this, leave it always as the last element
      /// For internal use only.
    OPTION_LAST;
  typedef fl_option = Fl_Option;


  //$ Return a global setting for all FLTK applications, possibly overridden
  //$ by a setting specifically for this application.

  fun option:fl_option->bool = "Fl::option($1)";

  //$ Override an option while the application is running.
  proc option: fl_option*bool = "Fl::option($1,$2);";

    /**
    This does the same thing as Fl::visual(int) but also requires OpenGL
    drawing to work. This <I>must</I> be done if you want to draw in
    normal windows with OpenGL with gl_start() and gl_end().
    It may be useful to call this so your X windows use the same visual
    as an Fl_Gl_Window, which on some servers will reduce colormap flashing.

    See Fl_Gl_Window for a list of additional values for the argument.
  */
  gen gl_visual: int*int->int = "Fl::gl_visual($1,$2)";
  gen gl_visual: int->int = "Fl::gl_visual($1)";

  proc own_colormap: unit = "Fl::own_colormap();";
  proc get_system_colors: unit = "Fl::get_system_colors();";
  proc foreground: utiny*utiny*utiny = "Fl::foreground($1,$2,$3);";
  proc background: utiny*utiny*utiny = "Fl::background($1,$2,$3);";
  proc background2: utiny*utiny*utiny = "Fl::background2($1,$2,$3);";
  // schemes:
  fun scheme:string->int = "Fl::scheme(const_cast<char *>(strdup($1.c_str()))";
  /** See void scheme(const char *name) */
  fun scheme:1->string = "Fl::scheme()";
  /** 
    Called by scheme according to scheme name. 
    Loads or reloads the current scheme selection. 
    See void scheme(const char *name) 
  */
  fun reload_scheme: 1->int = "Fl::reload_scheme()";
  fun scrollbar_size: 1->int = "Fl::scrollbar_size()";
  proc scrollbar_size:int = "Fl::scrollbar_size($1);";
  fun readqueue: 1->fl_widget = "Fl::readqueue()";
  /**
  Adds a one-shot timeout callback.  The function will be called by
  Fl::wait() at <i>t</i> seconds after this function is called.
  The optional void* argument is passed to the callback.
  
  You can have multiple timeout callbacks. To remove a timeout
  callback use Fl::remove_timeout().
  
  If you need more accurate, repeated timeouts, use Fl::repeat_timeout() to
  reschedule the subsequent timeouts.
  
  The following code will print "TICK" each second on
  stdout with a fair degree of accuracy:
  
  \code
     void callback(void*) {
       puts("TICK");
       Fl::repeat_timeout(1.0, callback);
     }
  
     int main() {
       Fl::add_timeout(1.0, callback);
       return Fl::run();
     }
  \endcode
  */
  proc add_timeout: double*fl_timeout_handler*address = "Fl::add_timeout($1,$2,$3);";
  proc add_timeout: double*fl_timeout_handler = "Fl::add_timeout($1,2);";

  /**
  Repeats a timeout callback from the expiration of the
  previous timeout, allowing for more accurate timing. You may only call
  this method inside a timeout callback.
  
  The following code will print "TICK" each second on
  stdout with a fair degree of accuracy:
  
  \code
     void callback(void*) {
       puts("TICK");
       Fl::repeat_timeout(1.0, callback);
     }
  
     int main() {
       Fl::add_timeout(1.0, callback);
       return Fl::run();
     }
  \endcode
  */
  proc repeat_timeout: double*fl_timeout_handler*address = "Fl::repeat_timeout($1,$2,$3);";
  proc repeat_timeout: double*fl_timeout_handler = "Fl::repeat_timeout($1,2);";
  fun  has_timeout: fl_timeout_handler*address->int = "Fl::has_timeout($1,$2)";
  fun  has_timeout: fl_timeout_handler->int = "Fl::has_timeout($1)";
  proc remove_timeout: fl_timeout_handler*address = "Fl::remove_timeout($1,$2);";
  proc remove_timeout: fl_timeout_handler = "Fl::remove_timeout($1);";

  proc add_check: fl_timeout_handler*address = "Fl::add_check($1,$2);";
  proc add_check: fl_timeout_handler = "Fl::add_check($1);";
  fun  has_check: fl_timeout_handler*address->int = "Fl::has_check($1,$2)";
  fun  has_check: fl_timeout_handler->int = "Fl::has_check($1)";
  proc remove_check: fl_timeout_handler*address = "Fl::remove_check($1,$2);";
  proc remove_check: fl_timeout_handler = "Fl::remove_check($1);";
  /**
    Adds file descriptor fd to listen to.
    
    When the fd becomes ready for reading Fl::wait() will call the
    callback and then return. The callback is passed the fd and the
    arbitrary void* argument.
    
    The second version takes a when bitfield, with the bits
    FL_READ, FL_WRITE, and FL_EXCEPT defined,
    to indicate when the callback should be done.
    
    There can only be one callback of each type for a file descriptor. 
    Fl::remove_fd() gets rid of <I>all</I> the callbacks for a given
    file descriptor.
    
    Under UNIX <I>any</I> file descriptor can be monitored (files,
    devices, pipes, sockets, etc.). Due to limitations in Microsoft Windows,
    WIN32 applications can only monitor sockets.
  */
 proc add_fd: int*int*fl_fd_handler*address = "Fl::add_fd($1,$2,$3,$4);"; // platform dependent
  /** See void add_fd(int fd, int when, Fl_FD_Handler cb, void* = 0) */
  proc add_fd: int*fl_fd_handler*address = "Fl::add_fd($1,$2,$3);"; // platform dependent
  proc add_fd: int*fl_fd_handler = "Fl::add_fd($1,$2);"; // platform dependent
  /** Removes a file descriptor handler. */
  proc remove_fd:int*int = "Fl::remove_fd($1,$2);";
  /** Removes a file descriptor handler. */
  proc remove_fd: int = "Fl::remove_fd($1);"; // platform dependent

  proc add_idle: fl_idle_handler*address = "Fl::add_idle($1,$2);";
  proc add_idle: fl_idle_handler = "Fl::add_idle($1);";
  fun  has_idle: fl_idle_handler*address->int = "Fl::has_idle($1,$2)";
  proc remove_idle: fl_idle_handler*address = "Fl::remove_idle($1,$2);";
  proc remove_idle: fl_idle_handler = "Fl::remove_idle($1);";
  /** If true then flush() will do something. */
  fun damage: 1->int = "Fl::damage()";
  proc redraw: 1  = "Fl::redraw();";
  proc flush: 1 = "Fl::flush();";

}

class Fl_Box {
  inherit Fl_Widget_[fl_box];
  ctor fl_box : int*int*int*int*string = "new Fl_Box($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";              
  ctor fl_box : int*int*int*int*int*string = "new Fl_Box($1,$2,$3,$4,$5,const_cast<char *>(strdup($6.c_str())))";
       
  ctor fl_box : fl_boxtype*int*int*int*int*string = "new Fl_Box($1,$2,$3,$4,$5,const_cast<char *>(strdup($6.c_str())))";
  ctor fl_box : fl_boxtype*int*int*int*int = "new Fl_Box($1,$2,$3,$4,$5,0)";
}

class Fl_Group[T in Fl_Groups] {
  inherit Fl_Widget_[T];
  inherit Fl_Common[T];
  ctor fl_group: int*int*int*int*string = "new Fl_Group($1,$2,$3,$4,$5.c_str())";
  ctor fl_group: int*int*int*int = "new Fl_Group($1,$2,$3,$4)";
  proc begin: T = "$1->begin();";
  proc end: T = "$1->end();";
  fun  current:T->fl_group = "$1->current();";
  proc current:T*fl_group = "$1->current($2);";
  fun  children:T->int = "$1->children()";
  /**
    Returns array()[n].  <i>No range checking is done!</i>
  */
  fun child: T*int->fl_widget = "$1->child($2)";
  fun find: T*fl_widget->int = "$1->find($2)";
  proc resize: T*int*int*int*int = "$1->resize($1,$2,$3,$3);";
  proc add: T*fl_widget = "$1->add($2);";
  proc insert: T*fl_widget*int = "$1->insert($2, $3);";
  /**
    This does insert(w, find(before)).  This will append the
    widget if \p before is not in the group.
  */
  proc insert: T*fl_widget*fl_widget = "$1->insert($2,$3);";
  proc remove: T*int = "$1->remove($2);";
  proc remove: T*fl_widget = "$1->remove($2);";
  proc clear:  T = "$1->clear();";

  proc resizable[V in Fl_Widgets]: T*V = "$1->resizable($2);";
  fun  get_resizable: T->fl_widget = "$1->resizable()";
  proc add_resizable: T*fl_widget = "$1->add_resizable($2)";
  proc init_sizes: T = "$1->init_sizes();";
  proc clip_children: T*int ="$1->clip_children($2);";
  fun get_clip_children: T->uint = "$1->clip_children()";

  // Note: Doxygen docs in Fl_Widget.H to avoid redundancy.
  //virtual fl_group* as_group() { return this; }
}


class Fl_Window_[T in Fl_Windows] {

//$    The destructor <I>also deletes all the children</I>. This allows a
//$    whole tree to be deleted at once, without having to keep a pointer to
//$    all the children in the user code. A kludge has been done so the 
//$    Fl_Window and all of its children can be automatic (local)
//$    variables, but you must declare the Fl_Window <I>first</I> so
//$    that it is destroyed last.
//  proc delete: T = "delete $1;";

//$    Changes the size and position of the window.  If shown() is true,
//$    these changes are communicated to the window server (which may
//$    refuse that size and cause a further resize).  If shown() is
//$    false, the size and position are used when show() is called.
//$    See Fl_Group for the effect of resizing on the child widgets.
//$
//$    You can also call the Fl_Widget methods size(x,y) and position(w,h),
//$    which are inline wrappers for this virtual function.
//$
//$    A top-level window can not force, but merely suggest a position and 
//$    size to the operating system. The window manager may not be willing or 
//$    able to display a window at the desired position or with the given 
//$    dimensions. It is up to the application developer to verify window 
//$    parameters after the resize request.
  proc resize: T*int*int*int*int = "$1->resize($2,$3,$4,$5);";
//$    Sets whether or not the window manager border is around the
//$    window.  The default value is true. void border(int) can be
//$    used to turn the border on and off. <I>Under most X window
//$    managers this does not work after show() has been called,
//$    although SGI's 4DWM does work.</I>
  proc border: T*int = "$1->border($2);";
//$    Fast inline function to turn the window manager border
//$    off. It only works before show() is called.
  proc clear_border: T = "$1->clear_border();";
//$    See void Fl_Window::border(int) 
  fun border: T->uint = "$1->border()";
//$    Activates the flags NOBORDER|FL_OVERRIDE 
  proc set_override:T = "$1->set_override()";
//$    Returns non zero if FL_OVERRIDE flag is set, 0 otherwise. 
  fun override: T->uint = "$1->override()";
//$    A "modal" window, when shown(), will prevent any events from
//$    being delivered to other windows in the same program, and will also
//$    remain on top of the other windows (if the X window manager supports
//$    the "transient for" property).  Several modal windows may be shown at
//$    once, in which case only the last one shown gets events.  You can see
//$    which window (if any) is modal by calling Fl::modal().
  proc set_modal: T = "$1->set_modal();";
//$    Returns true if this window is modal.  
  fun modal: T->uint = "$1->modal()";
//$    A "non-modal" window (terminology borrowed from Microsoft Windows)
//$    acts like a modal() one in that it remains on top, but it has
//$    no effect on event delivery.  There are <I>three</I> states for a
//$    window: modal, non-modal, and normal.
  proc set_non_modal: T = "$1->set_non_modal();";
//$    Returns true if this window is modal or non-modal. 
  fun non_modal: T->uint = "$1->non_modal()";
//$    Marks the window as a menu window.
//$
//$    This is intended for internal use, but it can also be used if you
//$    write your own menu handling. However, this is not recommended.
//$
//$    This flag is used for correct "parenting" of windows in communication
//$    with the windowing system. Modern X window managers can use different
//$    flags to distinguish menu and tooltip windows from normal windows.
//$
//$    This must be called before the window is shown and cannot be changed
//$    later.
  proc set_menu_window: T = "$1->set_menu_window();";
//$    Returns true if this window is a menu window. 
  fun menu_window: T->uint = "$1->menu_window();";
//$    Marks the window as a tooltip window.
//$
//$    This is intended for internal use, but it can also be used if you
//$    write your own tooltip handling. However, this is not recommended.
//$
//$    This flag is used for correct "parenting" of windows in communication
//$    with the windowing system. Modern X window managers can use different
//$    flags to distinguish menu and tooltip windows from normal windows.
//$
//$    This must be called before the window is shown and cannot be changed
//$    later.
//$
//$    \note Since Fl_Tooltip_Window is derived from Fl_Menu_Window, this
//$    also \b clears the menu_window() state.
  proc set_tooltip_window: T = "set_tooltip_window();";
//$    Returns true if this window is a tooltip window. 
  fun tooltip_window: T->uint = "tooltip_window()";
//$    Positions the window so that the mouse is pointing at the given
//$    position, or at the center of the given widget, which may be the
//$    window itself.  If the optional offscreen parameter is
//$    non-zero, then the window is allowed to extend off the screen (this
//$    does not work with some X window managers). \see position()
  proc hotspot: T*int*int*int ="$1->hotspot(int,int,int,hotspot);";
//$   See void Fl_Window::hotspot(int x, int y, int offscreen = 0) 
  proc hotspot: T*fl_widget*int = "$1->hotspot($2,$3,$4);";
//$   See void Fl_Window::hotspot(int x, int y, int offscreen = 0) 
//  proc hotspot: T*Fl_widget*int = "$1->hotspot(void hotspot(const Fl_Widget& p, int offscreen = 0) {hotspot(&p,offscreen);}
//$    Undoes the effect of a previous resize() or show() so that the next time
//$    show() is called the window manager is free to position the window.
//$
//$    This is for Forms compatibility only.
//$
//$    \deprecated please use force_position(0) instead
  proc free_position: T = "$1->free_position();";
//$    Sets the allowable range the user can resize this window to.
//$    This only works for top-level windows.
//$     <UL>
//$     <LI>minw and minh are the smallest the window can be.
//$	Either value must be greater than 0.</LI>
//$     <LI>maxw and maxh are the largest the window can be. If either is
//$	<I>equal</I> to the minimum then you cannot resize in that direction.
//$	If either is zero  then FLTK picks a maximum size in that direction
//$	such that the window will fill the screen.</LI>
//$     <LI>dw and dh are size increments.  The  window will be constrained
//$	to widths of minw + N * dw,  where N is any non-negative integer.
//$	If these are less or equal to 1 they are ignored (this is ignored
//$	on WIN32).</LI>
//$     <LI>aspect is a flag that indicates that the window should preserve its
//$	aspect ratio.  This only works if both the maximum and minimum have
//$	the same aspect ratio (ignored on WIN32 and by many X window managers).
//$	</LI>
//$    </UL>
//$
//$    If this function is not called, FLTK tries to figure out the range
//$    from the setting of resizable():
//$    <UL>
//$    <LI>If resizable() is NULL (this is the  default) then the window cannot
//$	be resized and the resize border and max-size control will not be
//$	displayed for the window.</LI>
//$    <LI>If either dimension of resizable() is less than 100, then that is
//$	considered the minimum size.  Otherwise the resizable() has a minimum
//$	size of 100.</LI>
//$    <LI>If either dimension of resizable() is zero, then that is also the
//$	maximum size (so the window cannot resize in that direction).</LI>
//$    </UL>
//$
//$    It is undefined what happens if the current size does not fit in the
//$    constraints passed to size_range().
  proc size_range: T*int*int*int*int*int*int*int = "$1->size_range($2,$3,$4,$5,$6,$7);";
//$   See void Fl_Window::label(const char*)   
//  const char* label() const	{return Fl_Widget::label();}
//  fun get_label: T->string = "$1->label()";
//$    See void Fl_Window::iconlabel(const char*)   
//  const char* iconlabel() const	{return iconlabel_;}
  fun get_iconlabel: T->string = "const_cast<char *>($1->label())";
//$   Sets the window title bar label. 
//  proc label: T*string = "$1->label(const_cast<char *>($2.c_str()));";
//$   Sets the icon label. 
  proc iconlabel: T*string ="$1->iconlabel(const_cast<char *>($2.c_str()));";
//$   Sets the icon label. 
  proc label: T*string*string = "$1->label(const_cast<char *>($2.c_str()),const_cast<char *>($2.c_str()));";
//  void copy_label(const char* a);
  proc default_xclass: string ="Fl_Window::default_xclass(const_cast<char *>($1.c_str());";
//  static const char *default_xclass();
  fun get_default_xclass: 1->string = "Fl_Window::default_xclass()";
  proc xclass: T*string = "$1->xclass(const_cast<char *>($2.c_str()));";
  fun get-icon: T->address = "$1->icon()";
  proc icon: T*address ="$1->icon($2);";
//$    Returns non-zero if show() has been called (but not hide()
//$    ). You can tell if a window is iconified with (w->shown()
//$    && !w->visible()).
  fun shown: T->int = "$1->shown()";
//$    Puts the window on the screen. Usually (on X) this has the side
//$    effect of opening the display.
//$
//$    If the window is already shown then it is restored and raised to the
//$    top.  This is really convenient because your program can call show()
//$    at any time, even if the window is already up.  It also means that
//$    show() serves the purpose of raise() in other toolkits.
//$    
//$    Fl_Window::show(int argc, char **argv) is used for top-level
//$    windows and allows standard arguments to be parsed from the
//$    command-line.
//$    
//$    \see Fl_Window::show(int argc, char **argv)
//  proc show: T = "$1->show();";
//$    Removes the window from the screen.  If the window is already hidden or
//$    has not been shown then this does nothing and is harmless.
//  proc hide: T = "$1->hide();";
//$    Puts the window on the screen and parses command-line arguments.
//$
//$    Usually (on X) this has the side effect of opening the display.
//$
//$    This form should be used for top-level windows, at least for the
//$    first (main) window. It allows standard arguments to be parsed
//$    from the command-line. You can use \p argc and \p argv from
//$    main(int argc, char **argv) for this call.
//$
//$    The first call also sets up some system-specific internal
//$    variables like the system colors.
//$
//$    \todo explain which system parameters are set up.
//$
//$    \param argc command-line argument count, usually from main()
//$    \param argv command-line argument vector, usually from main()
//$
//$    \see virtual void Fl_Window::show()
  proc show: T*int*&&char = "$1->show($2,$3);";
//$    Makes the window completely fill the screen, without any window
//$    manager border visible.  You must use fullscreen_off() to undo
//$    this. This may not work with all window managers.
  proc fullscreen: T = "$1->fullscreen();";
//$    Turns off any side effects of fullscreen() and does 
//$    resize(x,y,w,h).
  proc fullscreen_off: T*int*int*int*int = "$1->fullscreen_off($2,$3,$4,$5);";
//$    Iconifies the window.  If you call this when shown() is false
//$    it will show() it as an icon.  If the window is already
//$    iconified this does nothing.
//$
//$    Call show() to restore the window.
//$
//$    When a window is iconified/restored (either by these calls or by the
//$    user) the handle() method is called with FL_HIDE and 
//$    FL_SHOW events and visible() is turned on and off.
//$
//$    There is no way to control what is drawn in the icon except with the
//$    string passed to Fl_Window::xclass().  You should not rely on
//$    window managers displaying the icons.
  proc iconize: T = "$1->iconize();";
  fun x_root: T->int = "$1->x_root()";
  fun y_root: T->int = "$1->y_root()";
  fun current: 1->fl_window = "current()";
//$    Sets things up so that the drawing functions in <FL/fl_draw.H> will go
//$    into this window. This is useful for incremental update of windows, such
//$    as in an idle callback, which will make your program behave much better
//$    if it draws a slow graphic. <B>Danger: incremental update is very hard to
//$    debug and maintain!</B>
//$
//$    This method only works for the Fl_Window and Fl_Gl_Window derived classes.
  proc make_current: T = "$1->make_current();";
//$   Note: Doxygen docs in Fl_Widget.H to avoid redundancy.
  fun as_window: T->fl_window = "$1->as_window()";
//$    Changes the cursor for this window.  This always calls the system, if
//$    you are changing the cursor a lot you may want to keep track of how
//$    you set it in a static variable and call this only if the new cursor
//$    is different.
//$
//$    The type Fl_Cursor is an enumeration defined in <FL/Enumerations.H>.
//$    (Under X you can get any XC_cursor value by passing 
//$    Fl_Cursor((XC_foo/2)+1)).  The colors only work on X, they are
//$    not implemented on WIN32.
//$
//$    For back compatibility only.
proc cursor: T*Fl_Cursor*Fl_Color*Fl_Color = "$1->cursor($2,$3,$4);";
proc cursor: T*Fl_Cursor*Fl_Color = "$1->cursor($2,$3);";
proc cursor: T*Fl_Cursor = "$1->cursor($2);";

//  void default_cursor(Fl_Cursor, Fl_Color=FL_BLACK, Fl_Color=FL_WHITE);
//  static void default_callback(Fl_Window*, void* v);
  
//$   Returns the window width including any frame added by the window manager.
//$  
//$   Same as w() if applied to a subwindow.

  fun decorated_w: T->int = "$1->decorated_w()";
//$   Returns the window height including any window title bar and any frame 
//$   added by the window manager.
//$   
//$   Same as h() if applied to a subwindow.
  fun decorated_h: T->int = "$1->decorated_h()";
}

class Fl_Window {
  inherit Fl_Group[fl_window];  
  inherit Fl_Window_[fl_window];
//$  This widget produces an actual window.  This can either be a main
//$  window, with a border and title and all the window management controls,
//$  or a "subwindow" inside a window.  This is controlled by whether or not
//$  the window has a parent().
//$
//$  Once you create a window, you usually add children Fl_Widget
//$  's to it by using window->add(child) for each new widget.
//$  See Fl_Group for more information on how to add and remove children.
//$
//$  There are several subclasses of Fl_Window that provide
//$  double-buffering, overlay, menu, and OpenGL support.
//$
//$  The window's callback is done if the user tries to close a window
//$  using the window manager and Fl::modal() is zero or equal to the
//$  window. Fl_Window has a default callback that calls Fl_Window::hide().
//$    Creates a window from the given size and title. 
//$    If Fl_Group::current() is not NULL, the window is created as a 
//$    subwindow of the parent window.
//$    
//$    The (w,h) form of the constructor creates a top-level window
//$    and asks the window manager to position the window. The (x,y,w,h)
//$    form of the constructor either creates a subwindow or a
//$    top-level window at the specified location (x,y) , subject to window
//$    manager configuration. If you do not specify the position of the
//$    window, the window manager will pick a place to show the window
//$    or allow the user to pick a location. Use position(x,y)
//$    or hotspot() before calling show() to request a
//$    position on the screen. See Fl_Window::resize() 
//$    for some more details on positioning windows.
//$    
//$    Top-level windows initially have visible() set to 0
//$    and parent() set to NULL. Subwindows initially
//$    have visible() set to 1 and parent() set to
//$    the parent window pointer.
//$    
//$    Fl_Widget::box() defaults to FL_FLAT_BOX. If you plan to
//$    completely fill the window with children widgets you should
//$    change this to FL_NO_BOX. If you turn the window border off
//$    you may want to change this to FL_UP_BOX.
//$
//$    \see Fl_Window(int x, int y, int w, int h, const char* title)
  ctor fl_window : int*int*string = "new Fl_Window($1,$2,$3.c_str())";
//$    Creates a window from the given position, size and title.
//$    \see Fl_Window(int w, int h, const char *title)
  ctor fl_window : int*int*int*int*string = "new Fl_Window($1,$2,$3,$4,$5.c_str())";
}

class Fl_Double_Window {
  //$ See Fl_Window_ 
  inherit Fl_Group[fl_double_window];  
  inherit Fl_Window_[fl_double_window];
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  //  void show();
  //  void show(int a, char **b) {Fl_Window::show(a,b);}
  proc flush: fl_double_window = "$1->flush();";
  //$Creates a new Fl_Double_Window widget using the given
  //$  position, size, and label (title) string.
  ctor fl_double_window : int*int*string = "new Fl_Double_Window($1,$2,const_cast<char *>($3.c_str()))";
//$
//$   See  Fl_Double_Window::Fl_Double_Window(int w, int h, const char *label = 0)
  ctor fl_double_window : int*int*int*int*string = "new Fl_Double_Window($1,$2,$3,$4,const_cast<char *>($3.c_str()))";
}


class Fl_Image_Mixin[T] {
  fun w: T->int = "$1->w()";
  fun h: T->int = "$1->h()";
  fun d: T->int = "$1->d()";
  fun ld: T->int = "$1->ld()";
  fun count: T->int = "$1->count()";
  gen data: T->string = "$T->data()";
  virtual fun copy: T*int*int->T;
  fun copy (self:T):T => copy(self,w(self), h(self));
  virtual proc color_average: T*Fl_Color*float;
  proc inactive: T = "$1->inactive();";
  virtual proc desaturate: T;
  virtual proc label: T*fl_widget;
  virtual proc label: T*fl_menu_item;
  virtual proc draw:T*int*int*int*int*int*int; // platform dependent
  proc draw (self:T,x:int,y:int) => draw(self,x, x, w(self), h(self), 0, 0); // platform dependent
  virtual proc uncache:T;
}

class Fl_Image[T in Fl_Images] {
  
  // inherit Fl_Image_Mixin;
  ctor fl_image: int*int*int ="new Fl_Image($1,$2,$3)";
  //virtual ~Fl_Image();
    fun w: T->int = "$1->w()";
  fun h: T->int = "$1->h()";
  fun d: T->int = "$1->d()";
  fun ld: T->int = "$1->ld()";
  fun count: T->int = "$1->count()";
  gen data: T->string = "$T->data()";
  virtual fun copy: T*int*int->T;
  fun copy (self:T):T => copy(self,w(self), h(self));
  virtual proc color_average: T*Fl_Color*float;
  proc inactive: T = "$1->inactive();";
  virtual proc desaturate: T;
  virtual proc label: T*fl_widget;
  virtual proc label: T*fl_menu_item;
  virtual proc draw:T*int*int*int*int*int*int; // platform dependent
  proc draw (self:T,x:int,y:int) => draw(self,x, x, w(self), h(self), 0, 0); // platform dependent
  virtual proc uncache:T;
}


class Fl_RGB_Image[T in Fl_RGB_Images] {
  //  inherit Fl_Image_Mixin;
  ctor fl_rgb_image: +utiny*int*int*int*int = "new Fl_RGB_Image($1,$2,$3,$4,$5)";
}

//$  The Fl_PNM_Image class supports loading, caching,
//$  and drawing of Portable Anymap (PNM, PBM, PGM, PPM) image files. The class
//$  loads bitmap, grayscale, and full-color images in both ASCII and
//$  binary formats.
class Fl_PNM_Image[T in Fl_RGB_Images] {
  //  inherit Fl_Image_Mixin;
  ctor fl_pnm_image: string = "new Fl_PNM_Image(const_cast<char *>(strdup($1.cstr())))";
}

@h3
 Shared images class. 

  This class supports caching, loading,
  and drawing of image files. Most applications will also want to
  link against the fltk_images library and call the
  fl_register_images()
  function to support standard image formats such as BMP, GIF, JPEG, and PNG
@felix
class Fl_Shared_Image {
  //$ Returns the filename of the shared image */
  fun name: fl_shared_image->carray[char] = "$1->name()";
  //$ Returns the number of references of this shared image. When reference is below 1, the image is deleted. */
  fun refcount: fl_shared_image->int ="$1->refcount()";
  proc release: fl_shared_image = "$1->release();";
  proc reload: fl_shared_image = "$1->reload();";

  fun copy: fl_shared_image*int*int->fl_image = "$1->copy($2,$3)";
  fun copy: fl_shared_image->fl_image = "$1->copy($1->w(),$1->h())";
  proc color_average: fl_shared_image*fl_color*float = "$1->color_average($1,$2);";
  proc desaturate: fl_shared_image = "$1->desaturate();";
  //$ draw(int X, int Y, int W, int H, int cx, int cy);
  proc draw: fl_shared_image*int*int*int*int*int*int = "$1->draw($2,$3,$4,$5,$6,$7);";
  proc draw: fl_shared_image*int*int = "$1->draw($2,$3,$1->w(),$1->h(),0,0);";
  proc uncache: fl_shared_image = "$1->uncache();";
  
  fun find: string*int*int->fl_shared_image = "Fl_Shared_Image::find(const_cast<char *>(strdup($1.c_str())),$2,$3)";
  fun find: string*int->fl_shared_image = "Fl_Shared_Image::find(const_cast<char *>(strdup($1.c_str())),$2)";
  fun find: string->fl_shared_image = "Fl_Shared_Image::find(const_cast<char *>(strdup($1.c_str())))";
  fun get: string*int*int->fl_shared_image = "Fl_Shared_Image::get(const_cast<char *>(strdup($1.c_str())),$2,$3)";
  fun get: string*int->fl_shared_image = "Fl_Shared_Image::get(const_cast<char *>(strdup($1.c_str())),$2)";
  fun get: string->fl_shared_image = "Fl_Shared_Image::get(const_cast<char *>(strdup($1.c_str())))";
  fun images: 1->carray[fl_shared_image] = "Fl_Shared_Image::images()";
  fun num_images: 1->int = "Fl_Shared_images::num_images();";
  proc add_handler: fl_shared_image_handler = "Fl_Shared_Image::add_handler($1);";
  proc remove_handler: fl_shared_image_handler = "Fl_Shared_Image::remove_handler($1);";

}
//
//$ The following function is provided in the fltk_images library and
//$ registers all of the "extra" image file formats that are not part
//$ of the core FLTK library...
//$
proc fl_register_images: 1 ="fl_register_images();";

class Do_Callback_Mixin[t] {
  proc do_callback:t = "$1->do_callback();";
  proc do_callback:t*!Fl_Widgets*long = "$1->do_callback($2,$3);";
  proc do_callback:t*!Fl_Widgets*address = "$1->do_callback($2,$3);";
}

//type fl_label = "Fl_Label *";
cstruct  Fl_Label {
  /** label text */
  value:carray[char];
  /** optional image for an active label */
  image:fl_image;
  /** optional image for a deactivated label */
  deimage:fl_image;
  /** label font used in text */
  font:fl_font;
  /** size of label font */
  size:fl_fontsize;
  /** text color */
  color:fl_color;
  /** alignment of label */
  align_:fl_align;
  /** type of label. \see Fl_Labeltype */
  type_:utiny;
};
typedef fl_label = Fl_Label;
  /** Draws the label aligned to the given box */
//  void draw(int,int,int,int, Fl_Align) const ;
//  void measure(int &w, int &h) const ;



class Fl_Widget_[T in Fl_Widgets] {
  /* Should work I think, but it doesn't
  [mk_varmap] wrong number of type args, expected vs=1, got ts=0
  inherit Do_Callback_Mixin[T in Fl_Widgets];*/ 
  proc do_callback:T = "$1->do_callback();";
  proc do_callback:T*!Fl_Widgets*long = "$1->do_callback($2,$3);";
  proc do_callback:T*!Fl_Widgets*address = "$1->do_callback($2,$3);";
  fun  handle: T*int->int = "$1->handle($2)";
  fun parent: T->fl_group = "$1->parent()";
  fun get_type:T->utiny = "$1->type()";
  proc set_type:T*utiny = "$1->type($2);"; 
  proc set_type:T*popup_buttons = "$1->type($2);"; 
  fun x: T-> int = "$1->x()";
  fun y: T-> int = "$1->y()";
  fun w: T-> int = "$1->w()";
  fun h: T-> int = "$1->h()";
  proc resize: T*int*int*int*int = "$1->resize($2,$3,$4,$5);";
  proc position: T*int*int = "$1->position($2,$3);";
  proc size: T*int*int = "$1->size($2,$3);";
  proc align: T*Fl_Align = "$1->align($2);";
  fun  align: T->Fl_Align = "$1->align();";
  proc box: T*fl_boxtype = "$1->box($2);";
  fun  get_box: T->fl_boxtype = "$1->box()";
  proc selection_color: T*Fl_Color = "$1->color($2);";
  fun  get_selection_color: T->Fl_Color = "$1->color()";
  proc color: T*Fl_Color = "$1->color($2);";
  proc color: T*Fl_Color*Fl_Color = "$1->color($2, $3);";
  fun  get_color: T->Fl_Color = "$1->color();";
  fun  get_label: T->string = "$1->label();";
  proc label: T*string = "$1->label(strdup($2.c_str()));"; 
  proc label: T*Fl_Labeltype*string ="$1->label($2,strdup($3.c_str()));"; 
  proc labeltype: T*Fl_Labeltype = "$1->labeltype($2);";
  fun  get_labeltype: T->Fl_Labeltype = "$1->labeltype()";
  proc labelfont: T*Fl_Font = "$1->labelfont($2);";
  fun  get_labelfont: T->Fl_Font = "$1->labelfont()";
  proc labelsize: T*Fl_Fontsize = "$1->labelsize($2);";
  fun  get_labelsize: T->Fl_Fontsize = "$1->labelsize()";
  proc labelcolor: T*Fl_Color = "$1->labelcolor($2);";
  fun  get_labelcolor: T->Fl_Color = "$1->labelcolor()";
  fun  get_image:T->fl_image =  "$1->image()";
  //const Fl_Image* image() const {return label_.image;}
  proc image:T*fl_image = "$1->image($2);";
  //void image(Fl_Image& img) {label_.image=&img;}
  fun deimage:T->fl_image = "$1->deimage()";
  //const Fl_Image* deimage() const {return label_.deimage;}
  proc deimage:T*fl_image = "$1->image($2);";
  //void deimage(Fl_Image& img) {label_.deimage=&img;}
  fun get_tooltip: T->string = "$1->tooltip()";
  proc tooltip:T*string = "$1->tooltip(strdup($2.c_str()));";
  //void copy_tooltip(const char *text);		// see Fl_Tooltip
//  Fl_Callback_p callback() const {return callback_;}
  proc set_callback[V]:T*Fl_Callback*V = "$1->callback($2,$3);";
  proc set_callback:T*Fl_Callback = "$1->callback($2);";
  proc set_callback:T*Fl_Callback0 = "$1->callback($2);";
  proc set_callback:T*Fl_Callback1*long = "$1->callback($2,$3);";
  proc set_callback:T*Fl_Callback1*Fl_When = "$1->callback($2,$3);";
  fun  get_user_data:T->address = "$1->user_data()";
  proc user_data:T*address = "$1->user_data($2)";
  fun  argument:T->long = "$1->argument()";
  proc argument:T*long = "$1->argument($2);";
//  Fl_When when() const {return (Fl_When)when_;}
  fun get_when: T->fl_when = "$1->when()";
  proc when:T*utiny = "$1->when($2);";
  fun visible:T->uint = "$1->visible()";
  fun visible_r:T->int = "$1->visible_r()";
  /* virtual */ proc show: T = "$1->show();";
  /* virtual */ proc hide: T = "$1->hide();";
  proc set_visible: T = "$1->set_visible();";
  proc clear_visible: T = "$1->clear_visible();";
  fun active: T->uint = "$1->active()";
  fun active_r: T->int = "$1->active_r()";
  proc activate: T = "$1->activate();";
  proc deactivate: T = "$1->deactivate();";
  fun output: T->uint = "$1->output()";
  proc set_output: T = "$1->set_output();";
  proc clear_output: T = "$1->clear_output();";
  fun takesevents: T->uint = "$1->takesevents()";
  fun changed: T->int = "$1->changed()";
  proc set_changed: T = "$1->set_output();";
  proc clear_changed: T = "$1->clear_output();";
  fun focus: T->int = "$1->changed()";
  proc set_visible_focus: T = "$1->set_visible_focus();";
  proc clear_visible_focus: T = "$1->clear_visible_focus();";
  fun get_visible_focus: T->int = "$1->visible_focus()";
  proc visible_focus: T*int = "$1->visible_focus($2);";
  proc default_callback: T*!Fl_Widgets*address = "$1->default_callback($2,$3);";

  fun contains: T*!Fl_Widgets->int = "$1->contains($2)";
  fun inside: T*!Fl_Widgets->int = "$1->inside($2)";
  proc redraw:T = "$1->redraw();"; // was do_redraw why?
  proc redraw_label:T = "$1->do_redraw_label();";	
  fun get_damage: T->utiny = "$1->damage()";
  proc clear_damage:T*utiny = "$1->clear_damage($2);";
  proc damage: T->utiny = "$1->damage()";
  proc damage: T->utiny*int*int*int*int = "$1->damage($2,$3,$4,$5,$6)";
  proc draw_label: T->int*int*int*int*Fl_Align = "$1->draw_label($2,$3,$4,$5,$6)";
  //void measure_label(int& ww, int& hh) const {label_.measure(ww, hh);}
  virtual fun as_group:T->fl_group = "$1->as_group()";
  virtual fun as_window:T->fl_group = "$1->as_window()";
  //virtual class Fl_Gl_Window* as_gl_window() {return 0;}

}

//$  \class Fl_Button
//$  \brief Buttons generate callbacks when they are clicked by the user.
//$  
//$    You control exactly when and how by changing the values for type() and
//$    when().  Buttons can also generate callbacks in response to \c FL_SHORTCUT
//$    events.  The button can either have an explicit shortcut(int s) value or a
//$    letter shortcut can be indicated in the label() with an '\&' character
//$    before it.  For the label shortcut it does not matter if \e Alt is held
//$    down, but if you have an input field in the same window, the user will have
//$    to hold down the \e Alt key so that the input field does not eat the event
//$    first as an \c FL_KEYBOARD event.
//$  
//$    \todo Refactor the doxygen comments for Fl_Button type() documentation.
//$  
//$    For an Fl_Button object, the type() call returns one of:
//$    \li \c FL_NORMAL_BUTTON (0): value() remains unchanged after button press.
//$    \li \c FL_TOGGLE_BUTTON: value() is inverted after button press.
//$    \li \c FL_RADIO_BUTTON: value() is set to 1 after button press, and all other
//$           buttons in the current group with <tt>type() == FL_RADIO_BUTTON</tt>
//$  	 are set to zero.

//$  \todo Refactor the doxygen comments for Fl_Button when() documentation.

//$    For an Fl_Button object, the following when() values are useful, the default
//$    being \c FL_WHEN_RELEASE:
//$    \li \c 0: The callback is not done, instead changed() is turned on.
//$    \li \c FL_WHEN_RELEASE: The callback is done after the user successfully
//$           clicks the button, or when a shortcut is typed.
//$    \li \c FL_WHEN_CHANGED: The callback is done each time the value() changes
//$           (when the user pushes and releases the button, and as the mouse is
//$  	 dragged around in and out of the button).
class Fl_Common_Button[T in Fl_Buttons] {
  //inherit Fl_Common[T];
  const FL_NORMAL_BUTTON:int;
  const FL_TOGGLE_BUTTON:int;
  const FL_RADIO_BUTTON:int;
  const FL_HIDDEN_BUTTON:int;

  type FL_Widget_Tracker = "class FL_Widget_Tracker";
  fun value:T*int->int =  "$1->value($2)";
  //$ Sets value (0 or 1)  fun  value: T*int->int = "$1->value($2)";
  //$  Returns the current value of the button (0 or 1).
  fun  get_value: T->int = "$1->value()";
  //$ Same as \c value(1).
  //$  \see value(int v)
  fun  set: T->int = "$1->set()";
  //$  Same as \c value(0).
  //$  \see value(int v)
  fun  clear:T->int = "$1->clear()";
  //$ this should only be called on FL_RADIO_BUTTONs
  proc setonly: T = "$1->setonly();"; 
  //$  Returns the current shortcut key for the button.
  //$  \retval int
  fun shortcut: T->int = "$1->shortcut()";
  //$  Sets the shortcut key to \c s.
  //$  Setting this overrides the use of '\&' in the label().
  //$  The value is a bitwise OR of a key and a set of shift flags, for example:
  //$  <tt>FL_ALT | 'a'</tt>, or
  //$  <tt>FL_ALT | (FL_F + 10)</tt>, or just
  //$  <tt>'a'</tt>.
  //$  A value of 0 disables the shortcut.
  //$
  //$  The key can be any value returned by Fl::event_key(), but will usually be
  //$  an ASCII letter.  Use a lower-case letter unless you require the shift key
  //$  to be held down.
  //$
  //$  The shift flags can be any set of values accepted by Fl::event_state().
  //$  If the bit is on, that shift key must be pushed.  Meta, Alt, Ctrl, and
  //$  Shift must be off if they are not in the shift flags (zero for the other
  //$  bits indicates a "don't care" setting).
  //$  \param[in] s bitwise OR of key and shift flags
  proc shortcut: T*int = "$1->shortcut($2);";
  //$  Returns the current down box type, which is drawn when value() is non-zero.
  //$  \retval Fl_Boxtype
  fun get_down_box: T->fl_boxtype = "$1->down_box()";
  //$  Sets the down box type. The default value of 0 causes FLTK to figure out
  //$  the correct matching down version of box().
  //$  \param[in] b down box type
  proc down_box: T*fl_boxtype ="$1->down_box($2);";

}

class Fl_Widget {
  inherit Fl_Common_Button[fl_button];
  inherit Fl_Group[fl_button];
  inherit Fl_Widget_[fl_widget];
}

class Fl_Button {
  inherit Fl_Common_Button[fl_button];
  inherit Fl_Group[fl_button];
  inherit Fl_Widget_[fl_button];  
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_button: int*int*int*int*string = "new Fl_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
}

class Fl_Check_Button {
  inherit Fl_Common_Button[fl_check_button];
  inherit Fl_Group[fl_check_button];
  inherit Fl_Widget_[fl_check_button];   
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_check_button: int*int*int*int*string = "new Fl_Check_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
}


class Fl_Light_Button {
  inherit Fl_Common_Button[fl_light_button];
  inherit Fl_Group[fl_light_button];
  inherit Fl_Widget_[fl_light_button];   
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_light_button: int*int*int*int*string = "new Fl_Light_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
}

class Fl_Radio_Button {
  inherit Fl_Group[fl_radio_button];
  inherit Fl_Widget_[fl_radio_button];   
  inherit Fl_Common_Button[fl_radio_button];
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_radio_button: int*int*int*int*string = "new Fl_Radio_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
}

class Fl_Radio_Light_Button {
  inherit Fl_Group[fl_radio_light_button];
  inherit Fl_Widget_[fl_radio_light_button];   
  inherit Fl_Common_Button[fl_radio_light_button];
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_radio_light_button: int*int*int*int*string = "new Fl_Radio_Light_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
}

class Fl_Radio_Round_Button {
  inherit Fl_Group[fl_radio_round_button];
  inherit Fl_Widget_[fl_radio_round_button];   
  inherit Fl_Common_Button[fl_radio_round_button];
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_radio_round_button: int*int*int*int*string = "new Fl_Radio_Round_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
}


class Fl_Repeat_Button {
  inherit Fl_Group[fl_repeat_button];
  inherit Fl_Widget_[fl_repeat_button];   
  inherit Fl_Common_Button[fl_repeat_button];
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_repeat_button: int*int*int*int*string = "new Fl_Repeat_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
}


class Fl_Return_Button {
  inherit Fl_Group[fl_return_button];
  inherit Fl_Widget_[fl_return_button];   
  inherit Fl_Common_Button[fl_return_button];
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_return_button: int*int*int*int*string = "new Fl_Return_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
}

class Fl_Round_Button {
  inherit Fl_Group[fl_round_button];
  inherit Fl_Widget_[fl_round_button];   
  inherit Fl_Common_Button[fl_round_button];
  //$ Button constructor 
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_round_button: int*int*int*int*string = "new Fl_Round_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
}

@h3
  The toggle button is a push button that needs to be clicked once 
  to toggle on, and one more time to toggle off.
  The Fl_Toggle_Button subclass displays the "on" state by
  drawing a pushed-in button.</P>
  <P>Buttons generate callbacks when they are clicked by the user.  You
  control exactly when and how by changing the values for type()
  and when().
@felix
class Fl_Toggle_Button {
  inherit Fl_Common_Button[fl_toggle_button];
  inherit Fl_Group[fl_toggle_button];
  inherit Fl_Widget_[fl_toggle_button];   

  //$ Button constructor 
  //$ Creates a new Fl_Toggle_Button widget using the given
  //$  position, size, and label string.
  //$  <P>The inherited destructor deletes the toggle button.
  //$ Args X:int , Y:int, Width:int Height:int Label:string
  ctor fl_toggle_button: int*int*int*int*string = "new Fl_Toggle_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  ctor fl_toggle_button: int*int*int*int = "new Fl_Toggle_Button($1,$2,$3,$4)";
}


header """
Fl_Menu_Item  make_empty_fl_menu_item() {
  struct Fl_Menu_Item *ret, flmi = {0};
  ret = (Fl_Menu_Item *)malloc(sizeof *ret); *ret = flmi;
  return *ret;
}
""";

//$ Menu structures which are passed to menu are treminated by a
//$ empty FL_Menu_Item structure ust this to provide that
fun Empty_Fl_Menu_Item: 1->fl_menu_item = "make_empty_fl_menu_item()";

class Fl_Menu_Item__[T in Fl_Menu_Items] {
  inherit Do_Callback_Mixin[T];

  // advance N items, skipping submenus:
  fun next:int->T = "$1->next($2)";
  //const_cast? fun next:int->Fl_Menu_Item = "$1->next($2)";
  //Fl_Menu_Item *next(int i=1) {
  //  return (Fl_Menu_Item*)(((const Fl_Menu_Item*)this)->next(i));}
  /** Returns the first menu item, same as next(0). */
  fun first: T->T = "$1->*first()";
  //const Fl_Menu_Item *first() const { return next(0); }
  
  fun  get_label: T->string = "const_cast<char *>(&$1->label())";
  proc label:T*string = "$1->label(const_cast<char *>($2.c_str()));";
  proc label:T*Fl_Labeltype*string = "$1->label($2,const_cast<char *>($3.c_str()));";
  fun  get_labeltype: T->Fl_Labeltype = "$1->labeltype()";
  proc labeltype: T*Fl_Labeltype = "$1->labeltype($2);";
  fun  get_labelcolor: T->Fl_Color = "$1->labelcolor()";
  proc labelcolor: T*Fl_Color = "$1->labelcolor($2)";
  fun  get_labelfont:T->Fl_Font = "$1->labelfont()";
  proc labelfont: T*Fl_Font = "$1->labelfont($2);";
  fun  get_labelsize: T->Fl_Fontsize = "$1->labelsize()";
  proc labelsize: T*Fl_Fontsize = "$1->labelsize($2);";
  proc set_callback: T*+Fl_Callback*address = "$1->callback($2,$3);";
  proc set_callback: T*+Fl_Callback = "$1->callback($2);";
  proc set_callback: T*+Fl_Callback0 = "$1->callback($2);";
  proc set_callback: T*+Fl_Callback1*long = "$1->callback($2,$3);";
  fun  get_user_data: T->address = "$1->user_data()";
  proc user_data: T*address ="$1->user_data($2);";
  fun  get_argument: T->long = "$1->argument()";
  proc argument: T*long = "$1->argument($2);";
  fun  get_shortcut: T->int = "$1->shortcut()";
  proc shortcut: T*int = "$1->shortcut($2);";
  fun  submenu: T->int = "$1->submenu()";
  fun  checkbox: T->int = "$1->ckeckbox()";
  fun  radio: T->int = "$1->radio()";
  fun  value: T->int = "$1->value()";
  proc set: T = "$1->shortcut();";
  proc clear: T = "$1->clear();";
  proc setonly: T = "$1->setonly();";
  fun  visible: T->int = "$1->visible()";
  proc show: T = "$1->show();";
  proc hide: T = "$1->hide();";
  fun  active: T->int = "$1->active()";
  proc activate: T = "$1->activate();";
  proc deactivate: T = "$1->deactivate();";
  fun  activevisible: T->int = "$1->activevisible()";
  //void image(Fl_Image* a) {a->label(this);}
  //void image(Fl_Image& a) {a.label(this);}
  fun popup: T*int*int*string*T*fl_menu_->fl_menu_item = "$1->popup($2,$3,const_cast<char *>($4.c_str()),const_cast<Fl_Menu_Item>($5),const_cast<Fl_Menu_>($6))"; 
  fun pulldown: T*int*int*int*int*string*fl_menu_item*fl_menu_*fl_menu_item*int->fl_menu_item = "$1->popup($2,$3,$4,$5,const_cast<char *>($6.c_str()),const_cast<Fl_Menu_Item>($7),const_cast<Fl_Menu_>($8),const_cast<Fl_Menu_Item>($9),$10)"; 
  fun test_shortcut: T->fl_menu_item = "$1->test_shortcut();";
  fun find_shortcut: T*int*bool->fl_menu_item = "$1->find_shortcut($2,const_cast<bool>($3))";
  proc delete: T = "free $1;";

}

class Fl_Menu_Item_ {
  inherit Fl_Menu_Item__[fl_menu_item];
  ctor fl_menu_item() => Empty_Fl_Menu_Item();

  ctor fl_menu_item(text:string) = {
    var mi = Empty_Fl_Menu_Item();
    (*mi).text = cstr(text);
    return mi;
  }

  ctor fl_menu_item(text:string,shortcut_:int) = {
    var mi = Empty_Fl_Menu_Item();
    (*mi).text = cstr(text);
    (*mi).shortcut_ =  shortcut_;
    return mi;
  }
  ctor fl_menu_item(text:string,shortcut_:int,callback_:Fl_Callback) = {
    var mi = Empty_Fl_Menu_Item();
    (*mi).text = cstr(text);
    (*mi).shortcut_ =  shortcut_;
    (*mi).callback_ = callback_;
    return mi;
  }

  ctor fl_menu_item(text:string,shortcut_:int,callback_:Fl_Callback,user_data_:address,flags:int) = {
    var mi = Empty_Fl_Menu_Item();
    (*mi).text = cstr(text);
    (*mi).shortcut_ =  shortcut_;
    (*mi).callback_ = callback_;
    (*mi).user_data_ =  user_data_;
    (*mi).flags = flags;
    return mi;
  }

  ctor fl_menu_item(text:string,shortcut_:int,callback_:Fl_Callback,user_data_:address,flags:int,labeltype_:utiny) = {
    var mi = Empty_Fl_Menu_Item();
    (*mi).text = cstr(text);
    (*mi).shortcut_ =  shortcut_;
    (*mi).callback_ = callback_;
    (*mi).user_data_ =  user_data_;
    (*mi).flags = flags;
    (*mi).labeltype_ = labeltype_;
    return mi;
  }

  ctor fl_menu_item(text:string,shortcut_:int,callback_:Fl_Callback,user_data_:address,flags:int,labeltype_:utiny,labelfont_:Fl_Font,labelsize_:Fl_Fontsize) = {
    var mi = Empty_Fl_Menu_Item();
    (*mi).text = cstr(text);
    (*mi).shortcut_ =  shortcut_;
    (*mi).callback_ = callback_;
    (*mi).user_data_ =  user_data_;
    (*mi).flags = flags;
    (*mi).labeltype_ = labeltype_;
    (*mi).labelfont_ = labelfont_;
    (*mi).labelsize_ = labelsize_;
    return mi;
  }


  ctor fl_menu_item(text:string,shortcut_:int,callback_:Fl_Callback,user_data_:address,flags:int,labeltype_:utiny,labelfont_:Fl_Font,labelsize_:Fl_Fontsize,labelcolor_:Fl_Color) = {
    var mi = Empty_Fl_Menu_Item();
    (*mi).text = cstr(text);
    (*mi).shortcut_ =  shortcut_;
    (*mi).callback_ = callback_;
    (*mi).user_data_ =  user_data_;
    (*mi).flags = flags;
    (*mi).flags = flags;
    (*mi).labeltype_ = labeltype_;
    (*mi).labelfont_ = labelfont_;
    (*mi).labelsize_ = labelsize_;
    (*mi).labelcolor_ = labelcolor_;
    return mi;
  }

}

class Fl_Menu_Bar {
  inherit Fl_Common[fl_menu_bar];
  inherit Fl_Menu__[fl_menu_bar];
  inherit Fl_Menu_Item__[fl_menu_bar];
  
@h4    Creates a new Fl_Menu_Bar widget using the given position,
    size, and label string. The default boxtype is FL_UP_BOX.
    <P>The constructor sets menu() to NULL.  See 
    Fl_Menu_ for the methods to set or change the menu. </P>
    <P>labelsize(), labelfont(), and labelcolor()
    are used to control how the menubar items are drawn.  They are
    initialized from the Fl_Menu static variables, but you can
    change them if desired. </P>
    <P>label() is ignored unless you change align() to
    put it outside the menubar.
    <P>The destructor removes the Fl_Menu_Bar widget and all of its
    menu items.
@felix
  ctor fl_menu_bar:int*int*int*int*string = "new Fl_Menu_Bar($1,$2,$3,$4,const_cast<char *>($5.c_str()))";
}


@h3   Base class of all widgets that have a menu in FLTK.
  Currently FLTK provides you with 
  Fl_Menu_Button, Fl_Menu_Bar, and Fl_Choice.
  
  <P>The class contains a pointer to an array of structures of type  Fl_Menu_Item.  The
  array may either be supplied directly by the user program, or it may
  be "private": a dynamically allocated array managed by the Fl_Menu_.
@felix
class Fl_Menu__ [T in Fl_Menus] {

  fun item_pathname: T*string*int*fl_menu_item->int = "$1->item_pathname($1,const_cast<char *>($2),$3,$4)";
  fun picked: T*fl_menu_item->fl_menu_item = "$1->picked(const_cast<Fl_Menu_item *>($2))";
  fun find_item: T*string->fl_menu_item = "$1->find_item(const_cast<char *>($2))";
  fun find_item: T*Fl_Callback->fl_menu_item = "$1->find_item($2)";
  fun find_index:T*string->int = "$1->find_index(const_cast<char *>($2))";
  fun find_index:T*fl_menu_item->int = "$1->find_index(const_cast<Fl_Menu_Item *>($2))";
  fun find_index: T*Fl_Callback->int = "$1->find_index($2)";
@h3 Returns the menu item with the entered shortcut (key value).

    This searches the complete menu() for a shortcut that matches the
    entered key value.  It must be called for a FL_KEYBOARD or FL_SHORTCUT
    event.

    If a match is found, the menu's callback will be called.

    \return matched Fl_Menu_Item or NULL.
@felix
  fun test_shortcut:T->fl_menu_item = "$1->test_shortcut()";
  proc global: T = "$1->global();"; 

  
  //$  Returns a pointer to the array of Fl_Menu_Items.  This will either be
  //$  the value passed to menu(value) or the private copy.
  fun get_menu: T->fl_menu_item = "$1->menu()";
       //menu of fl_menu_bar * carray[FL_MENU_ITEM]
  //proc menu: T*&Fl_Menu_Item = "$1->menu(const_cast<Fl_Menu_Item *>($2));";
  proc menu: T*carray[fl_menu_item] = "$1->menu(const_cast<Fl_Menu_Item *>($2));";
  proc copy: T*fl_menu_item = "$1->menu(const_cast<Fl_Menu_Item *>($2),$3);";
  fun insert:T*int*string*int*Fl_Callback*address*int->int = "$1->insert($2,const_char<char *>($3.c_str()),$4,$5,$6)";
  fun add:T*string*int*Fl_Callback*address*int->int = "$1->add(const_char<char *>($2.c_str()),$3,$4,$5)";
  //$ See int Fl_Menu_::add(const char* label, int shortcut, Fl_Callback*, void *user_data=0, int flags=0)
  fun add:T*string*string*Fl_Callback*address*int->int = "$1->add(const_char<char *>($2.c_str()),const_char<char *>($3),$4,$5,$6)"; 
  //$ See int Fl_Menu_::insert(const char* label, int shortcut, Fl_Callback*, void *user_data=0, int flags=0) */
  fun insert:T*int*string*string*Fl_Callback*address*int->int = "$1->insert($2,const_char<char *>($3.c_str()),const_char<char *>($4),$5,$6,$7)"; 
  fun add:T*string->int = "$1->add(const_cast<char *>($2))";
  fun get_size:T->int = "$1->size()";
  proc size:T*int*int = "$1->size($2,$3);";
  proc clear:T = "$1->clear();";
  fun clear_submenu:T*int->int = "$1->clear_submenu()";  
  proc replace:T*int = "$1->replace($2);";
  proc remove:T*int = "$1->remove($2);";
  //$ Changes the shortcut of item i to n.
  proc shortcut:T*int*int = "$1->shortcut($2,$3);";
  //$ Sets the flags of item i.  For a list of the flags, see Fl_Menu_Item. 
  proc mode:T*int*int = "$1->mode($2,$3);";
  //$ Gets the flags of item i.  For a list of the flags, see Fl_Menu_Item.
  fun mode:T*int->int = "$1->mode($2)";
  //$ Returns a pointer to the last menu item that was picked.
  fun mvalue:T->fl_menu_item = "(Fl_Menu_Item *)($1->mvalue())";
  //$ Returns the index into menu() of the last item chosen by the user.  It is zero initially.
  fun value:T->int = "$1->value()";
  fun value:T*fl_menu_item->int = "$1->value(const_cast<Fl_Menu_Item>($2))";
@h3
    The value is the index into menu() of the last item chosen by
    the user.  It is zero initially.  You can set it as an integer, or set
    it with a pointer to a menu item.  The set routines return non-zero if
    the new value is different than the old one.
@felix
  fun value:T*int->int = "$1->value($2)";
  //$ Returns the title of the last item chosen.
  fun text: T->string = "$1->text()";
  //$ Returns the title of item i
  fun text: T*int->string = "$1->text($2)";
  //$ Gets the current font of menu item labels.
  fun get_textfont: T->Fl_Font = "$1->text()";
  //$  Sets the current font of menu item labels.
  proc textfont: T*Fl_Font = "$1->textfont($2);";
  //$  Gets the font size of menu item labels.
  fun get_textsize:T->Fl_Fontsize = "$1->textsize()";
  //$  Sets the font size of menu item labels.
  proc textsize:T*Fl_Fontsize = "$1->textsize($2)";
  //$ Get the current color of menu item labels.
  fun get_textcolor:T->Fl_Color = "$1->textcolor()";
  //$ Sets the current color of menu item labels.
  proc textcolor:T*Fl_Color = "$1->textcolor($2);";
@h3  This box type is used to surround the currently-selected items in the
    menus.  If this is FL_NO_BOX then it acts like 
    FL_THIN_UP_BOX and selection_color() acts like 
    FL_WHITE, for back compatibility.    
@felix
  fun get_down_box:T->fl_boxtype = "$1->down_box()";
  //$    See Fl_Boxtype Fl_Menu_::down_box() const
  proc down_box:T*fl_boxtype = "$1->down_box($2)";

}

class Fl_Menu_ {
  inherit Fl_Menu__[fl_menu_];
  inherit Fl_Widget_[fl_menu_];
  ctor fl_menu_:int*int*int*int*string = "new Fl_Menu_Bar($1,$2,$3,$4,const_cast<char *>($5.c_str()))";
}


@h3   This is a button that when pushed pops up a menu (or hierarchy of
  menus) defined by an array of 
  Fl_Menu_Item objects.
  <P ALIGN=CENTER>\image html  menu_button.png</P>
  \image latex  menu_button.png " menu_button" width=5cm
  <P>Normally any mouse button will pop up a menu and it is lined up
  below the button as shown in the picture.  However an Fl_Menu_Button
  may also control a pop-up menu.  This is done by setting the type().
  If type() is zero a normal menu button is produced. 
  If it is nonzero then this is a pop-up menu. The bits in type() indicate 
  what mouse buttons pop up the menu (see Fl_Menu_Button::popup_buttons). </P>
  <P>The menu will also pop up in response to shortcuts indicated by
  putting a '&' character in the label(). </P>
  <P>Typing the shortcut() of any of the menu items will cause
  callbacks exactly the same as when you pick the item with the mouse.
  The '&' character in menu item names are only looked at when the menu is
  popped up, however. </P>
  <P>When the user picks an item off the menu, the item's callback is
  done with the menu_button as the Fl_Widget* argument.  If the
  item does not have a callback the menu_button's callback is done
  instead.
@felix
class Fl_Menu_Button {
  inherit Fl_Common[fl_menu_button];
  inherit Fl_Menu__[fl_menu_button];
  inherit Fl_Widget_[fl_menu_button];
  fun popup: fl_menu_button->fl_menu_item = "$1->popup();";
  ctor fl_menu_button: int*int*int*int*string = "new Fl_Menu_Button($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  ctor fl_menu_button: int*int*int*int = "new Fl_Menu_Button($1,$2,$3,$4)";

}

@h3
  \class Fl_Choice
  \brief A button that is used to pop up a menu.

  This is a button that, when pushed, pops up a menu (or hierarchy of menus)
  defined by an array of Fl_Menu_Item objects.
  Motif calls this an OptionButton.

  The only difference between this and a Fl_Menu_Button is that the name of
  the most recent chosen menu item is displayed inside the box, while the
  label is displayed outside the box. However, since the use of this is most
  often to control a single variable rather than do individual callbacks,
  some of the Fl_Menu_Button methods are redescribed here in those terms.

  When the user picks an item off the menu the value() is set to that item
  and then the item's callback is done with the menu_button as the
  \c Fl_Widget* argument. If the item does not have a callback the
  menu_button's callback is done instead.

  All three mouse buttons pop up the menu. The Forms behavior of the first
  two buttons to increment/decrement the choice is not implemented.  This
  could be added with a subclass, however.

  The menu will also pop up in response to shortcuts indicated by putting
  a '\&' character in the label().  See Fl_Button::shortcut(int s) for a
  description of this.

  Typing the shortcut() of any of the items will do exactly the same as when
  you pick the item with the mouse.  The '\&' character in item names are
  only looked at when the menu is popped up, however.

  \image html choice.png
  \image latex choice.png  "Fl_Choice" width=4cm
  \todo Refactor the doxygen comments for Fl_Choice changed() documentation.

  \li <tt>int Fl_Widget::changed() const</tt>
      This value is true the user picks a different value. <em>It is turned
      off by value() and just before doing a callback (the callback can turn
      it back on if desired).</em>
  \li <tt>void Fl_Widget::set_changed()</tt>
      This method sets the changed() flag.
  \li <tt>void Fl_Widget::clear_changed()</tt>
      This method clears the changed() flag.
  \li <tt>Fl_Boxtype Fl_Choice::down_box() const</tt>
      Gets the current down box, which is used when the menu is popped up.
      The default down box type is \c FL_DOWN_BOX.
  \li <tt>void Fl_Choice::down_box(Fl_Boxtype b)</tt>
      Sets the current down box type to \p b.
@felix
class Fl_Choice  {
  inherit Fl_Common[fl_choice];
  inherit Fl_Menu__[fl_choice];
  inherit Fl_Widget_[fl_choice];
  ctor fl_choice: int*int*int*int*string = "new Fl_Choice($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  ctor fl_choice: int*int*int*int = "new Fl_Choice($1,$2,$3,$4)";
  //$  Gets the index of the last item chosen by the user.
  //$  The index is zero initially.
  fun value: fl_choice->int = "$1->value()";

  fun value: fl_choice*int->int = "$1->value($2)";

  fun value: fl_choice*fl_menu_item->int = "$1->value(const_cast<Fl_Menu_Item>($2))";

}


class Fl_Tooltip {
  
  //$    Gets the tooltip delay. The default delay is 1.0 seconds.  
  fun get_delay: 1 -> float = "Fl_Tooltip::delay()";
  //$    Sets the tooltip delay. The default delay is 1.0 seconds.  
  proc delay: float = "Fl_Tooltip::delay($1)";
  //$    Gets the tooltip hover delay, the delay between tooltips.
  //$    The default delay is 0.2 seconds.
  fun get_hoverdelay: 1 -> float = "Fl_Tooltip::hoverdelay()";
  //$    Sets the tooltip hover delay, the delay between tooltips.
  //$    The default delay is 0.2 seconds.
  proc hoverdelay: float = "Fl_Tooltip::hoverdelay($1)";
  //$    Returns non-zero if tooltips are enabled.  
  fun get_enabled: 1 -> int = "Fl_Tooltip::enabled()";
  //$    Enables tooltips on all widgets (or disables if <i>b</i> is false).  
  proc enable: int = "Fl_Tooltip::enable($1)";
  //$    Same as enable(0), disables tooltips on all widgets.  
  proc disable: int = "Fl_Tooltip::disable($1)";
  //static void (*enter)(Fl_Widget* w);
  proc enter_area:fl_widget*int*int*int*int*string = "Fl_Tooltip::enter_area($1,$2,$3,$4,$5,strdup($6.c_str()));";
  //static void (*exit)(Fl_Widget *w);
  //$ Gets the current widget target 
  fun get_current: 1->fl_widget = "Fl_Tooltip::current()";
  //$ Set the current widget target
  proc current: fl_widget = "Fl_Tooltip::current($1);";
  //$    Gets the typeface for the tooltip text.  
  fun get_font: 1->Fl_Font = "Fl_Tooltip::font()";
  //$    Sets the typeface for the tooltip text.  
  proc font: Fl_Font = "Fl_Tooltip::font($1);";
  //$    Gets the size of the tooltip text.  
  fun get_size: 1->Fl_Fontsize = "Fl_Tooltip::size()";
  //$    Sets the size of the tooltip text.  
  proc size: Fl_Fontsize = "Fl_Tooltip::size($1);";
  //$ Gets the background color for tooltips. The default background color is a pale yellow.  */
  fun get_color: 1->Fl_Color = "Fl_Tooltip::color()";
  //$ Sets the background color for tooltips. The default background color is a pale yellow.  */
  proc color: Fl_Color = "Fl_Tooltip::color($1)";
  //$ Gets the color of the text in the tooltip. The default is  black. 
  fun get_textcolor: 1->Fl_Color = "Fl_Tooltip::textcolor()";
  //$ Sets the color of the text in the tooltip. The default is  black. 
  proc textcolor: Fl_Color = "Fl_Tooltip::textcolor($1);";
}

@h3
  This class provides a low-overhead text input field.

  This is a virtual base class below Fl_Input. It has all
  the same interfaces, but lacks the handle() and
  draw() method. You may want to subclass it if you are
  one of those people who likes to change how the editing keys
  work. It may also be useful for adding scrollbars
  to the input field.

  This can act like any of the subclasses of Fl_Input, by
  setting type() to one of the following values:

  \code
  #define FL_NORMAL_INPUT	   0
  #define FL_FLOAT_INPUT	   1
  #define FL_INT_INPUT		   2
  #define FL_MULTILINE_INPUT	   4
  #define FL_SECRET_INPUT	   5
  #define FL_INPUT_TYPE		   7
  #define FL_INPUT_READONLY	   8
  #define FL_NORMAL_OUTPUT	   (FL_NORMAL_INPUT | FL_INPUT_READONLY)
  #define FL_MULTILINE_OUTPUT	   (FL_MULTILINE_INPUT | FL_INPUT_READONLY)
  #define FL_INPUT_WRAP		   16
  #define FL_MULTILINE_INPUT_WRAP  (FL_MULTILINE_INPUT | FL_INPUT_WRAP)
  #define FL_MULTILINE_OUTPUT_WRAP (FL_MULTILINE_INPUT | FL_INPUT_READONLY | FL_INPUT_WRAP)
  \endcode

  All variables that represent an index into a text buffer are byte-oriented,
  not character oriented. Since UTF-8 characters can be up to six bytes long,
  simply incrementing such an index will not reliably advance to the next character
  in the text buffer.

  Indices and pointers into the text buffer should always point at a 7 bit ASCII
  character or the beginning of a UTF-8 character sequence. Behavior for false
  UTF-8 sequences and pointers into the middle of a sequence are undefined.

  \see Fl_Text_Display, Fl_Text_Editor for more powerful text handling widgets

  \internal
  When porting this widget from ASCII to UTF-8, previously legal pointers into
  the text of this widget can become illegal by pointing into the middle of
  a UTF-8 sequence. This is not a big problem for Fl_Input_ because all code
  in this module is quite tolerant. It could be problematic though when deriving
  from this class because no feedback for illegal pointers is given. Additionally,
  a careless "copy" call can put partial UTF-8 sequences into the clipboard.

  None of these issues should be disastrous. Nevertheless, we should
  discuss how FLTK should handle false UTF-8 sequences and pointers.
@felix
 
class Fl_Input_ [T in Fl_Inputs] {
  const FL_NORMAL_INPUT:int;
  const FL_FLOAT_INPUT:int;
  const FL_INT_INPUT:int;
  const FL_HIDDEN_INPUT:int;
  const FL_MULTILINE_INPUT:int;
  const FL_SECRET_INPUT:int;
  const FL_INPUT_TYPE:int;
  const FL_INPUT_READONLY:int;
  const FL_NORMAL_OUTPUT:int;
  const FL_MULTILINE_OUTPUT:int;
  const FL_INPUT_WRAP:int;
  const FL_MULTILINE_INPUT_WRAP:int;
  const FL_MULTILINE_OUTPUT_WRAP:int;

  //$ Change the size of the widget. */
  proc resize: T*int*int*int*int = "$1->resize($2,$3,$4);";

  //$ Constructor */
  ctor fl_input_:int*int*int*int*string = "new Fl_Input_($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";

  //$ Changes the widget text. */
  gen value:T*string->int = "$1->value(const_cast<char *>(strdup($2.c_str())))";

  //$ Changes the widget text. */
  gen value:T*string*int->int = "$1->value(const_cast<char *>(strdup($2.c_str())),$3)";

  //$ Changes the widget text. */
  //$ Changes the widget text. */
  gen static_value:T*string->int = "$1->static_value(const_cast<char *>(strdup($2.c_str())))";

 //$ Changes the widget text. */
  gen static_value:T*string*int->int = "$1->static_value(const_cast<char *>(strdup($2.c_str())),$3)";

@h3
      Returns the text displayed in the widget.

      This function returns the current value, which is a pointer
      to the internal buffer and is valid only until the next event is
      handled.
  
      \return pointer to an internal buffer - do not free() this    
      \see Fl_Input_::value(const char*)
@felix
  fun get_value:T->string = "$1->value()";

  //$ Returns the character at index \p i. */
  fun index: T*int->fl_char = "$1->index($2)";

@h3
    Returns the number of bytes in value(). 
  
    This may be greater than <tt>strlen(value())</tt> if there are 
    \c nul characters in the text.

    \return number of bytes in the text
@felix
  fun val_size: T->int = "$1->size()";

@h3 Sets the width and height of this widget.
    \param [in] W, H new width and height
    \see Fl_Widget::size(int, int) */
@felix
  proc size:T*int*int = "$1->size($1,$2);";

  //$ Gets the maximum length of the input field.  
  //$  \todo It is not clear if this function is actually required */
  fun get_maximum_size: T->int = "$1->maximum_size($2)";

  //$ Sets the maximum length of the input field. 
  //$  \todo It is not clear if this function is actually required 
  proc maximum_size: T*int = "$1->maximum_size($2);";

  //$ Gets the position of the text cursor.
  //$  \return the cursor position as an index
  //$  \see position(int, int)
  fun get_position:T->int = "$1->position()";

  //$ Gets the current selection mark. 
  //$  \return index into the text */
  fun get_mark: T->int = "$1->mark()";

  //$ Sets the index for the cursor and mark. */
  gen position: T*int*int->int = "$1->position($2,$3)";

@h3   Set the cursor position and mark.
    position(n) is the same as <tt>position(n, n)</tt>.
    \param p new index for cursor and mark
    \return 0 if no positions changed
    \see position(int, int), position(), mark(int)
@felix
  gen position: T*int->int = "$1->position($2)";

@h3   Sets the current selection mark. 
    mark(n) is the same as <tt>position(position(),n)</tt>.
    \param m new index of the mark 
    \return 0 if the mark did not change
    \see position(), position(int, int) */
@felix
  gen mark: T*int->int = "$1->mark($2)";

  //$ Deletes text from b to e and inserts the new string text. */
  gen replace: T*int*int*string*int->int = "$1->replace($2,$3,const_cast<char *>strdup($4.c_str()),$5)";
  gen replace: T*int*int*string->int = "$1->replace($2,$3,const_cast<char *>strdup($4.c_str()))";

@h3    Deletes the current selection.

    This function deletes the currently selected text
    \e without storing it in the clipboard. To use the clipboard,
    you may call copy() first or copy_cuts() after
    this call.

    \return 0 if no data was copied
@felix
  gen cut:T->int = "$1->cut()";

@h3    Deletes the next \p n bytes rounded to characters before or after the cursor.

    This function deletes the currently selected text
    \e without storing it in the clipboard. To use the clipboard,
    you may call copy() first or copy_cuts() after
    this call.

    \param n number of bytes rounded to full characters and clamped to the buffer.
           A negative number will cut characters to the left of the cursor.
    \return 0 if no data was copied
@felix
  gen cut:T*int->int = "$1->cut($2)";

@h3
    Deletes all characters between index \p a and \p b.

    This function deletes the currently selected text
    \e without storing it in the clipboard. To use the clipboard,
    you may call copy() first or copy_cuts() after
    this call.

    \param a, b range of bytes rounded to full characters and clamped to the buffer
    \return 0 if no data was copied
@felix
  gen cut:T*int*int->int = "$1->cut($2,$3)";

@h3    Inserts text at the cursor position.

    This function inserts the string in \p t at the cursor
    position() and moves the new position and mark to
    the end of the inserted text.

    \param [in] t text that will be inserted
    \param [in] l length of text, or 0 if the string is terminated by \c nul.
    \return 0 if no text was inserted
@felix
  gen insert:T*string*int->int = "$1->int(const_cast<char *>(strdup($2.c_str())),$3)";
    gen insert:T*string->int = "$1->int(const_cast<char *>(strdup($2.c_str())))";

  //$ Put the current selection into the clipboard. */
  gen copy: T*int->int = "$1->copy($2)";

  //$ Undo previous changes to the text buffer. */
  gen undo: T->int = "$1->undo()";

  //$ Copy the yank buffer to the clipboard. */
  gen copy_cuts: T->int = "$1->undo()";

  //$ Return the shortcut key associated with this widget.
  //$  \return shortcut keystroke
  //$  \see Fl_Button::shortcut() */
  fun get_shortcut: T->int = "$1->shortcut()";

@h3 Sets the shortcut key associated with this widget.
    Pressing the shortcut key gives text editing focus to this widget.
    \param [in] s new shortcut keystroke 
    \see Fl_Button::shortcut() 
@felix
  proc shortcut: T*int = "$1->shortcut($2);";

  //$ Gets the font of the text in the input field.
  //$  \return the current Fl_Font index */
  fun get_textfont: T->fl_font = "$1->textfont()";

  //$ Sets the font of the text in the input field.
  //$  The text font defaults to \c FL_HELVETICA.
  //$  \param [in] s the new text font */
  proc textfont: T*fl_font = "$1->textfont($2);";

  //$ Gets the size of the text in the input field.
  //$  \return the text height in pixels */
  fun get_textsize: T->fl_fontsize = "$1->textsize()";

  //$ Sets the size of the text in the input field.
  //$  The text height defaults to \c FL_NORMAL_SIZE.
  //$  \param [in] s the new font height in pixel units */
  proc testsize: T*fl_fontsize = "$1->textsize($2);";

  //$ Gets the color of the text in the input field.
  //$  \return the text color
  //$  \see textcolor(Fl_Color) */
  fun get_textcolor: T->fl_color = "$1->textcolor()";

  //$ Sets the color of the text in the input field.
  //$  The text color defaults to \c FL_FOREGROUND_COLOR.
  //$  \param [in] n new text color
  //$  \see textcolor() */
  proc textcolor:T*fl_color = "$1->textcolor($2);";

  //* Gets the color of the cursor.  
  //$  \return the current cursor color */
  fun get_cursor_color: T->fl_color = "$1->cursor_color()";

  //$ Sets the color of the cursor.  
  //$  The default color for the cursor is \c FL_BLACK.
  //$  \param [in] n the new cursor color */
  proc cursor_color: T*fl_color = "$1->cursor_color($2);";

  //$ Gets the input field type. 
  //$  \return the current input type */
  fun get_input_type: T->int = "$1->input_type()";

  //$ Sets the input field type. 
  //$  A redraw() is required to reformat the input field.
  //$  \param [in] t new input type */
  proc input_type: T*int = "$1->input_type($2);";

  //$ Gets the read-only state of the input field.  
  //$  \return non-zero if this widget is read-only */
  fun get_readonly: T->int ="$1->readonly()";

  //$ Sets the read-only state of the input field.  
  //$  \param [in] b if \p b is 0, the text in this widget can be edited by the user */
  proc readonly: T*int = "$1->readolny($2);";

  //$  Gets  the word wrapping state of the input field. 
  //$  Word wrap is only functional with multi-line input fields.
  fun get_wrap: T->int = "$1->wrap()";

  //$  Sets the word wrapping state of the input field. 
  //$  Word wrap is only functional with multi-line input fields.
  proc wrap: T*int = "$1->wrap($2);";
@h3
    Sets whether the Tab key does focus navigation, 
    or inserts tab characters into Fl_Multiline_Input.

    By default this flag is enabled to provide the 'normal' behavior 
    most users expect; Tab navigates focus to the next widget. 
    To inserting an actual Tab character, users can use Ctrl-I
    or copy/paste.

    Disabling this flag gives the old FLTK behavior where Tab
    inserts a tab character into the text field, in which case
    only the mouse can be used to navigate to the next field.

    History: This flag was provided for backwards support of FLTK's old 1.1.x
    behavior where Tab inserts a tab character instead of navigating 
    focus to the next widget. This behavior was unique to Fl_Multiline_Input. 
    With the advent of Fl_Text_Editor, this old behavior has been deprecated.

    \param [in] val If \p val is 1, Tab advances focus (default).<BR>
                    If \p val is 0, Tab inserts a tab character (old FLTK behavior).
@felix
  proc tab_nav: T*int = "$1->tab_nav($2);";

@h3    Gets whether the Tab key causes focus navigation in multiline input fields or not.

    If enabled (default), hitting Tab causes focus navigation to the next widget.

    If disabled, hitting Tab inserts a tab character into the text field.
    \returns 1 if Tab advances focus (default), 0 if Tab inserts tab characters.
    \see tab_nav(int)
@felix
  fun get_tab_nav: T->int ="$1->tab_nav()";
}

@h3  This is the FLTK text input widget. It displays a single line
  of text and lets the user edit it. Normally it is drawn with an
  inset box and a white background. The text may contain any
  characters, and will correctly display any UTF text, using
  ^X notation for unprintable control characters. It assumes the
  font can draw any characters of the used scripts, which is true
  for standard fonts under MSWindows and Mac OS X.
  Characters can be input using the keyboard or the character palette/map.
  Character composition is done using dead keys and/or a compose
  key as defined by the operating system.
  <P>
  <TABLE WIDTH=90% BORDER=1 SUMMARY="Fl_Input keyboard and mouse bindings.">
    <CAPTION ALIGN=TOP>Fl_Input keyboard and mouse bindings.</CAPTION>
    <TR><TD NOWRAP="NOWRAP" WIDTH="1%">
      <B>Mouse button 1</B> 
    </TD><TD>
      Moves the cursor to this point. 
      Drag selects characters. 
      Double click selects words. 
      Triple click selects all line.
      Shift+click extends the selection.
      When you select text it is automatically copied to the selection buffer.
    </TD></TR><TR><TD NOWRAP="NOWRAP">
      <B>Mouse button 2</B> 
    </TD><TD>
      Insert the selection buffer at the point clicked.
      You can also select a region and replace it with the selection buffer
      by selecting the region with mouse button 2.
    </TD></TR><TR><TD NOWRAP="NOWRAP">
      <B>Mouse button 3</B>
    </TD><TD>
      Currently acts like button 1.
    </TD></TR><TR><TD NOWRAP="NOWRAP">
      <B>Backspace</B>
    </TD><TD>
      Deletes one character to the left, or deletes the selected region.
    </TD></TR><TR><TD NOWRAP="NOWRAP">
      <B>Delete</B>
    </TD><TD>
      Deletes one character to the right, or deletes the selected region.
      Combine with Shift for equivalent of ^X (copy+cut).
    </TD></TR><TR><TD NOWRAP="NOWRAP">
      <B>Enter</b>
    </TD><TD>
      May cause the callback, see when().
  </TD></TR></TABLE>

  <P>

  <TABLE WIDTH="90%" BORDER="1" SUMMARY="Fl_Input platform specific keyboard bindings.">
    <CAPTION ALIGN=TOP>Fl_Input platform specific keyboard bindings.</CAPTION>
  <TR>
    <TD NOWRAP="NOWRAP" WIDTH="1%"><B> Windows/Linux </B></TD>
    <TD NOWRAP="NOWRAP" WIDTH="1%"><B> Mac </B></TD>
    <TD NOWRAP="NOWRAP"           ><B> Function </B></TD>

  </TR><TR>
    <TD NOWRAP="NOWRAP"><B> ^A </B></TD>
    <TD NOWRAP="NOWRAP"><B> Command-A </B></TD>
    <TD>
      <B>Selects all text in the widget.</B>

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> ^C </B></TD>
    <TD NOWRAP="NOWRAP"><B> Command-C </B></TD>
    <TD>
      <B>Copy the current selection to the clipboard.</B>

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> ^I </B></TD>
    <TD NOWRAP="NOWRAP"><B> ^I </B></TD>
    <TD>
      <B>Insert a tab.</B>

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> ^J </B></TD>
    <TD NOWRAP="NOWRAP"><B> ^J </B></TD>
    <TD>
      <B>Insert a Line Feed.</B> <BR>
      (Similar to literal 'Enter' character)

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> ^L </B></TD>
    <TD NOWRAP="NOWRAP"><B> ^L </B></TD>
    <TD>
      <B>Insert a Form Feed.</B>

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> ^M </B></TD>
    <TD NOWRAP="NOWRAP"><B> ^M </B></TD>
    <TD>
      <B>Insert a Carriage Return.</B>

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> ^V,<BR>Shift-Insert </B></TD>
    <TD NOWRAP="NOWRAP"><B> Command-V </B></TD>
    <TD>
      <B>Paste the clipboard.</B> <BR>
      (Macs keyboards don't have "Insert" keys, 
      but if they did, Shift-Insert would work)

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> ^X,<BR>Shift-Delete </B></TD>
    <TD NOWRAP="NOWRAP"><B> Command-X,<BR>Shift-Delete </B></TD>
    <TD>
      <B>Cut.</B> <BR>
      Copy the selection to the clipboard and delete it.
      (If there's no selection, Shift-Delete acts like Delete)

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> ^Z </B></TD>
    <TD NOWRAP="NOWRAP"><B> Command-Z </B></TD>
    <TD>
      <B>Undo.</B> <BR>
      This is a single-level undo mechanism, but all adjacent 
      deletions and insertions are concatenated into a single "undo".
      Often this will undo a lot more than you expected. 

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> Shift-^Z </B></TD>
    <TD NOWRAP="NOWRAP"><B> Shift-Command-Z </B></TD>
    <TD>
      <B>Redo.</B> <BR>
      Currently same behavior as ^Z. 
      Reserved for future multilevel undo/redo.

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> Arrow Keys </B></TD>
    <TD NOWRAP="NOWRAP"><B> Arrow Keys </B></TD>
    <TD>
      <B>Standard cursor movement.</B> <BR>
      Can be combined with Shift to extend selection.

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> Home </B></TD>
    <TD NOWRAP="NOWRAP"><B> Command-Up,<BR>Command-Left </B></TD>
    <TD>
      <B>Move to start of line.</B> <BR>
      Can be combined with Shift to extend selection.

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> End </B></TD>
    <TD NOWRAP="NOWRAP"><B> Command-Down,<BR>Command-Right </B></TD>
    <TD>
      <B>Move to end of line.</B> <BR>
      Can be combined with Shift to extend selection.

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B>Ctrl-Home</B></TD>
    <TD NOWRAP="NOWRAP"><B>Command-Up,<BR>Command-PgUp,<BR>Ctrl-Left</B></TD>
    <TD>
      <B>Move to top of document/field.</B> <BR>
      In single line input, moves to start of line.
      In multiline input, moves to start of top line.
      Can be combined with Shift to extend selection.

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> Ctrl-End </B></TD>
    <TD NOWRAP="NOWRAP"><B> Command-End,<BR>Command-PgDn,<BR>Ctrl-Right</B></TD>
    <TD>
      <B>Move to bottom of document/field.</B> <BR>
      In single line input, moves to end of line.
      In multiline input, moves to end of last line.
      Can be combined with Shift to extend selection.

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> Ctrl-Left </B></TD>
    <TD NOWRAP="NOWRAP"><B> Alt-Left </B></TD>
    <TD>
      <B>Word left.</B> <BR>
      Can be combined with Shift to extend selection.

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> Ctrl-Right </B></TD>
    <TD NOWRAP="NOWRAP"><B> Alt-Right </B></TD>
    <TD>
      <B>Word right.</B> <BR>
      Can be combined with Shift to extend selection.

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> Ctrl-Backspace </B></TD>
    <TD NOWRAP="NOWRAP"><B> Alt-Backspace </B></TD>
    <TD>
      <B>Delete word left.</B>

  </TD></TR><TR>
    <TD NOWRAP="NOWRAP"><B> Ctrl-Delete </B></TD>
    <TD NOWRAP="NOWRAP"><B> Alt-Delete </B></TD>
    <TD>
      <B>Delete word right.</B>

  </TD></TR></TABLE>
@felix

class Fl_Input  {
  inherit Fl_Widget_[fl_input];
  inherit Fl_Group[fl_input];
  inherit Fl_Input_[fl_input];
  //  int handle(int);
  //$ Args X,Y,Length,Width,Label
       
  ctor fl_input: int*int*int*int*string = "new Fl_Input($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  //$ See fl_input int*int*int*int
  ctor fl_input: int*int*int*int = "new Fl_Input($1,$2,$3,$4)";
}

class Fl_Int_Input {
  inherit Fl_Widget_[fl_input];
  inherit Fl_Group[fl_input];
  inherit Fl_Input_[fl_input];  
@h3
    Creates a new Fl_Int_Input widget using the given position,
    size, and label string. The default boxtype is FL_DOWN_BOX.

    Inherited destructor destroys the widget and any value associated with it.
@felix
  // Args X,Y,Length,Width,Label
  ctor fl_int_input: int*int*int*int*string = "new Fl_Int_Input($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  //$ See fl_input int*int*int*int
  ctor fl_int_input: int*int*int*int = "new Fl_Int_Input($1,$2,$3,$4)";
}
  ctor fl_int_input: int*int*int*int*string = "new Fl_Int_Input($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  //$ See fl_input int*int*int*int
  ctor fl_int_input: int*int*int*int = "new Fl_Int_Input($1,$2,$3,$4)";

@h3    The Fl_Float_Input class is a subclass of Fl_Input
  that only allows the user to type floating point numbers (sign,
  digits, decimal point, more digits, 'E' or 'e', sign, digits).
@felix
class Fl_Float_Input {
  inherit Fl_Widget_[fl_float_input];
  inherit Fl_Group[fl_float_input];
  inherit Fl_Input_[fl_float_input];
  //$    Creates a new Fl_Float_Input widget using the given position,
  //$  size, and label string. The default boxtype is FL_DOWN_BOX.
  //$
  //$  Inherited destructor destroys the widget and any value associated with it.
    // Args X,Y,Length,Width,Label
  ctor fl_float_input: int*int*int*int*string = "new Fl_Float_Input($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  //$ See fl_float_input int*int*int*int
  ctor fl_float_input: int*int*int*int = "new Fl_Float_Input($1,$2,$3,$4)";

}
//  ctor fl_float_input: int*int*int*int*string = "new Fl_Float_Input($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  //$ See fl_float_input int*int*int*int
//  ctor fl_float_input: int*int*int*int = "new Fl_Float_Input($1,$2,$3,$4)";


@h3  The Fl_Secret_Input class is a subclass of Fl_Input that displays its
  input as a string of placeholders. Depending on the platform this
  placeholder is either the asterisk ('*') or the Unicode bullet
  character (U+2022).

  This subclass is usually used to receive passwords and other "secret" information.
@felix

class  Fl_Secret_Input  {
  inherit Fl_Widget_[fl_secret_input];
  inherit Fl_Group[fl_secret_input];
  inherit Fl_Input_[fl_secret_input];
@h3    Creates a new Fl_Secret_Input widget using the given
    position, size, and label string. The default boxtype is FL_DOWN_BOX.

    Inherited destructor destroys the widget and any value associated with it.
@felix
    // Args X,Y,Length,Width,Label
  ctor fl_secret_input: int*int*int*int*string = "new Fl_Secret_Input($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  //$ See fl_secret_input int*int*int*int
  ctor fl_secret_input: int*int*int*int = "new Fl_Secret_Input($1,$2,$3,$4)";
}

@h3  This input field displays '\n' characters as new lines rather than ^J,
  and accepts the Return, Tab, and up and down arrow keys.  This is for
  editing multiline text.

  This is far from the nirvana of text editors, and is probably only
  good for small bits of text, 10 lines at most. Note that this widget
  does not support scrollbars or per-character color control.

  If you are presenting large amounts of text and need scrollbars
  or full color control of characters, you probably want Fl_Text_Editor
  instead.

  In FLTK 1.3.x, the default behavior of the 'Tab' key was changed
  to support consistent focus navigation. To get the older FLTK 1.1.x
  behavior, set Fl_Input_::tab_nav() to 0. Newer programs should consider using
  Fl_Text_Editor.
@felix
class Fl_Multiline_Input {
  inherit Fl_Widget_[fl_multiline_input];
  inherit Fl_Group[fl_multiline_input];
  inherit Fl_Input_[fl_multiline_input];

@h3    Creates a new Fl_Multiline_Input widget using the given
    position, size, and label string. The default boxtype is FL_DOWN_BOX.

    Inherited destructor destroys the widget and any value associated with it.
@felix
    // Args X,Y,Length,Width,Label
  ctor fl_multiline_input: int*int*int*int*string = "new Fl_Multiline_Input($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  //$ See fl_secret_input int*int*int*int
  ctor fl_multiline_input: int*int*int*int = "new Fl_Multiline_Input($1,$2,$3,$4)";
}

@h3      \class Fl_Color_Chooser
  \brief The Fl_Color_Chooser widget provides a standard RGB color chooser.

  \image html fl_color_chooser.jpg
  \image latex fl_color_chooser.jpg "fl_color_chooser()" width=5cm

  You can place any number of the widgets into a panel of your own design.
  The diagram shows the widget as part of a color chooser dialog created by
  the fl_color_chooser() function. The Fl_Color_Chooser widget contains the
  hue box, value slider, and rgb input fields from the above diagram (it
  does not have the color chips or the Cancel or OK buttons).
  The callback is done every time the user changes the rgb value. It is not
  done if they move the hue control in a way that produces the \e same rgb
  value, such as when saturation or value is zero.

  The fl_color_chooser() function pops up a window to let the user pick an
  arbitrary RGB color. They can pick the hue and saturation in the "hue box"
  on the left (hold down CTRL to just change the saturation), and the
  brightness using the vertical slider. Or they can type the 8-bit numbers
  into the RGB Fl_Value_Input fields, or drag the mouse across them to adjust
  them.  The pull-down menu lets the user set the input fields to show RGB,
  HSV, or 8-bit RGB (0 to 255).

  fl_color_chooser() returns non-zero if the user picks ok, and updates the
  RGB values.  If the user picks cancel or closes the window this returns
  zero and leaves RGB unchanged.

  If you use the color chooser on an 8-bit screen, it will allocate all the
  available colors, leaving you no space to exactly represent the color the
  user picks! You can however use fl_rectf() to fill a region with a simulated
  color using dithering.
@felix
class Fl_Color_Chooser {
   //$  Returns which Fl_Color_Chooser variant is currently active 
   //$$  \return color modes are rgb(0), byte(1), hex(2), or hsv(3)   
   fun get_mode: fl_color_chooser->int = "$1->mode()";
  
  //$   Set which Fl_Color_Chooser variant is currently active 
  //$   \param[in] newMode color modes are rgb(0), byte(1), hex(2), or hsv(3)   
  proc mode: fl_color_chooser*int = "$1->mode($2);";
  
  //$  Returns the current hue.
  //$  0 <= hue < 6. Zero is red, one is yellow, two is green, etc.
  //$  <em>This value is convenient for the internal calculations - some other
  //$  systems consider hue to run from zero to one, or from 0 to 360.</em>
  fun hue: fl_color_chooser->double = "$1->hue()";

  //$  Returns the saturation.
  //$  0 <= saturation <= 1.
  fun saturation: fl_color_chooser->double = "$1->saturation()";

  //$  Returns the value/brightness.
  //$  0 <= value <= 1.
  fun value: fl_color_chooser->double = "$1->value()";

  //$  Returns the current red value.
  //$  0 <= r <= 1.
  fun r: fl_color_chooser->double = "$1->r()";

  //$  Returns the current green value.
  //$  0 <= g <= 1.
  fun g: fl_color_chooser->double = "$1->g()";

  //$  Returns the current blue value.
  //$  0 <= b <= 1.
  fun b: fl_color_chooser->double = "$1->b()";
  //$ Args H,S,V
  gen hsv: fl_color_chooser*double*double*double->int = "$1->hsv($1,$2,$3)";
  gen rgb: fl_color_chooser*double*double*double->int = "$1->rgb($1,$2,$3)";

  proc hsv2rgb: double*double*double*+double*+double*+double = "Fl_Color_Chooser::hsv2rgb($1,$2,$3,$4,$5,$6);";

  proc rgb2hsv: double*double*double*+double*+double*+double = "Fl_Color_Chooser::rgb2hsv($1,$2,$3,$4,$5,$6);";

  ctor fl_color_chooser: int*int*int*int*string = "new Fl_Color_Chooser($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  ctor fl_color_chooser: int*int*int*int = "new Fl_Color_Chooser($1,$2,$3,$4)";
}

type fl_help_dialog = "Fl_Help_Dialog *";

class Fl_Help_Dialog {
  ctor fl_help_dialog: 1 = "new Fl_Help_Dialog()";
  fun h: fl_help_dialog->int ="$1->h()";
  proc hide:  fl_help_dialog = "$1->hide();";
  proc load: fl_help_dialog*string = "$1->load(const_cast<char *>(strdup($2.c_str())));";
  //$ Args:x y
  proc position:fl_help_dialog*int*int = "$1->position($1,$2)";
  proc resize:fl_help_dialog*int*int*int = "$1->resize($1,$2,$3);"; 
  proc show:fl_help_dialog = "$1->show();";
  proc show:fl_help_dialog*int*carray[char] = "$1->show($1,$2);";
  proc textsize:fl_help_dialog*fl_fontsize = "$1->textsize($1);";
  fun get_textsize:fl_help_dialog->fl_fontsize = "$1->textsize();";
  proc topline:fl_help_dialog*string = "$1->topline(const_cast<char *>(strdup($2.c_str())));";
  proc topline:fl_help_dialog*int = "$1->topline($2);";
  proc set_value:fl_help_dialog*string = "$1->value(const_cast<char *>(strdup($2.c_str()))));";
  fun get_value:fl_help_dialog->string = "$1->value();";
  fun visible:fl_help_dialog->int = "$1->visible();";
  fun w:fl_help_dialog->int = "$1->y();";
  fun x:fl_help_dialog->int = "$1->x();";
  fun y:fl_help_dialog->int = "$1->y();";
  proc delete: fl_help_dialog = "free $1;";
}


class Fl_File_Icon {
 const FL_ICON_COLOR:Fl_Color;	/**< icon color [background?]*/
 cenum fl_file_types =		// File types
    ANY,			// Any kind of file
    PLAIN,			// Only plain files
    FIFO,			// Only named pipes
    DEVICE,			// Only character and block devices
    LINK,			// Only symbolic links
    DIRECTORY			// Only directories
  ;

  cenum fl_data_opcodes =	// Data opcodes
    END,			// End of primitive/icon
    COLOR,			// Followed by color value (2 shorts)
    LINE,			// Start of line
    CLOSEDLINE,			// Start of closed line
    POLYGON,			// Start of polygon
    OUTLINEPOLYGON,		// Followed by outline color (2 shorts)
    VERTEX			// Followed by scaled X,Y
  ;

  ctor fl_file_icon:string*int*int*short = "new Fl_File_Icon(const_cast<char *>(strdup($1.c_str()))),$2,$3,$4)";
  ctor fl_file_icon:string*int*int*short = "new Fl_File_Icon(const_cast<char *>(strdup($1.c_str()))),$2,$3)";
   ctor fl_file_icon:string*int*int*short = "new Fl_File_Icon(const_cast<char *>(strdup($1.c_str()))),$2)";

  fun add: fl_file_icon*short->carray[short] = "$1->add($2)";

  //$  Adds a color value to the icon array, returning a pointer to it.
  //$  \param[in] c color value
  fun add_color: fl_file_icon*short->carray[short] = "$1->add_color($2)";

  //$  Adds a vertex value to the icon array, returning a pointer to it.
  //$  The integer version accepts coordinates from 0 to 10000.
  //$  The origin (0.0) is in the lower-lefthand corner of the icon.
  //$  \param[in] x, y vertex coordinates
  fun add_vertex: fl_file_icon*int*int->carray[short] = "$1->add_vertex($2,$3)";

  //$  Adds a vertex value to the icon array, returning a pointer to it.
  //$  The floating point version goes from 0.0 to 1.0.
  //$  The origin (0.0) is in the lower-lefthand corner of the icon.
  //$  \param[in] x, y vertex coordinates
  fun add_vertex: fl_file_icon*float*float->carray[short] = "$1->add_vertex($2,$3)";

  //$ Clears all icon data from the icon.*/
  proc clear: fl_file_icon = "$1->clear()";
  //$ draw(int x, int y, int w, int h, Fl_Color ic, int active = 1)
  proc draw: fl_file_icon*int*int*int*int*fl_color*int = "$1->draw($2,$3,$4,$5,$6,$7);";
  proc draw: fl_file_icon*int*int*int*int*fl_color*int = "$1->draw($2,$3,$4,$5,$6);";
  proc label[T in Fl_Widgets]: fl_file_icon*T = "$1->label($2);";	
  proc labeltype:fl_label*int*int*int*int*fl_align = "Fl_File_Icon::labeltype($1,$2,$3,$4,$5,$6);";
  proc load: fl_file_icon*string = "$1->load(const_cast<char *>(strdup($2.c_str())));";
  proc load_fti: fl_file_icon*string = "$1->load_fti(const_cast<char *>(strdup($2.c_str())));";
  proc load_image: fl_file_icon*string = "$1->load_image(const_cast<char *>(strdup($2.c_str())));";

  //$ Returns next file icon object. See Fl_File_Icon::first() */
  fun next: fl_file_icon->fl_file_icon ="$1->next()";

  //$ Returns the filename matching pattern for the icon.*/
  fun pattern: fl_file_icon->string = "$1->pattern()";

  //$  Returns the number of words of data used by the icon.*/
  fun size: fl_file_icon->int = "$1->size()";

  
  //$  Returns the filetype associated with the icon, which can be one of the
  //$  following:
  
  //$  \li Fl_File_Icon::ANY, any kind of file.
  //$  \li Fl_File_Icon::PLAIN, plain files.
  //$  \li Fl_File_Icon::FIFO, named pipes.
  //$  \li Fl_File_Icon::DEVICE, character and block devices.
  //$  \li Fl_File_Icon::LINK, symbolic links.
  //$  \li Fl_File_Icon::DIRECTORY, directories.
  fun get_type: fl_file_icon->fl_file_types = "$1->type()"; 

  //$  Returns the data array for the icon.*/
  fun value: fl_file_icon->carray[short] = "$1->value()";

  fun find: string*fl_file_types->fl_file_icon = "Fl_File_Icon::find(const_cast<char *>(strdup($1.c_str())),$2)";
  

  //$ Returns a pointer to the first icon in the list.*/
  fun first: fl_file_icon->fl_file_icon ="$1->first()";
  proc load_system_icons: 1  = "Fl_File_Icon::load_system_icons();";

}

class Fl_File_Chooser {
  cenum fl_chooser_mode= SINGLE, MULTI, CREATE, DIRECTORY;

  ctor fl_file_chooser: string*string*int*string = "new Fl_File_Chooser(const_cast<char *>(strdup($1.c_str())),const_cast<char *>(strdup($2.c_str())),$3,const_cast<char *>(strdup($4.c_str())))";

  proc callback: fl_file_chooser*Fl_FileChooserCallback*address = "$1->callback($1,$2);";
  proc callback: fl_file_chooser*Fl_FileChooserCallback = "$1->callback($1);";
  proc color: fl_file_chooser*fl_color = "$1->color($2);";
  fun get_color: fl_file_chooser->fl_color = "$1->color()";
  fun count: fl_file_chooser->int = "$1->count()";
  proc directory: string = "$1->directory(const_char<char *>(strdup($2.c_str())));";
  fun get_directory: fl_file_chooser->string = "$1->directory()";
  proc filter:fl_file_chooser*string = "$1->filter(const_cast<char *>(strdup($2.c_str()));";
  fun get_filter: fl_file_chooser->string = "$1->filter()";  
  fun get_filter_value: fl_file_chooser->int = "$1->filter_value()";
  proc filter_value: fl_file_chooser*int = "$1->filter_value();";
  proc hide: fl_file_chooser = "$1->hide();";
  proc iconsize: fl_file_chooser*utiny = "$1->iconsize($2);";
  fun  get_iconsize: fl_file_chooser->utiny = "$1->iconsize()";
  proc label: fl_file_chooser*string = "$1->label(const_char<char *>(strdup($2.c_str())));";
  fun get_label: fl_file_chooser->string = "$1->label()";
  proc ok_label: fl_file_chooser*string = "$1->ok_label(const_char<char *>(strdup($2.c_str())));";
  fun get_ok_label: fl_file_chooser->string = "$1->ok_label()";
  proc preview: fl_file_chooser*utiny = "$1->preview($2);";
  fun  get_preview: fl_file_chooser->utiny = "$1->preview()";
  proc rescan: fl_file_chooser = "$1->rescan();";
  proc rescan_keep_filename: fl_file_chooser = "$1->rescan();";
  proc show: fl_file_chooser = "$1->rescan();";
  fun shown: fl_file_chooser->int = "$1->shown();";
  proc textcolor: fl_file_chooser*fl_color = "$1->textcolor($1);";
  fun get_textcolor: fl_file_chooser->fl_color = "$1->textcolor()";
  proc textfont: fl_file_chooser*fl_font = "$1->textfont($1);";
  fun get_textfont: fl_file_chooser->fl_font = "$1->textfont()";
  proc textsize: fl_file_chooser*fl_fontsize = "$1->textsize($1);";
  fun get_textsize: fl_file_chooser->fl_fontsize = "$1->textsize()";
  proc set_type: fl_file_chooser*int = "$1->type($1);";
  fun get_type: fl_file_chooser->int = "$1->type()";
  proc user_data: fl_file_chooser*address = "$1->user_data($1);";
  fun get_user_data: fl_file_chooser->address = "$1->user_data()";
  fun get_value: fl_file_chooser*int->string = "$1->value($1)";
  fun get_value: fl_file_chooser->string = "$1->value()";
  proc value: fl_file_chooser*string = "$1->value($2)";
  fun visible: fl_file_chooser->int = "$1->visible()";
  fun add_extra: fl_file_chooser*fl_widget->fl_widget = "$1->add_extra($2)";
  fun fl_dir_chooser: string*string*int->string = "fl_dir_chooser($1,$2,$3)";
  fun fl_dir_chooser: string*string->string = "fl_dir_chooser($1,$2)";
  fun fl_dir_chooser: string*string->string = "fl_dir_chooser($1,$2)";
  fun fl_file_chooser_str: string*string*int->string = "fl_file_chooser($1,$2,$3,$4)";
  fun fl_file_chooser_str: string*string->string = "fl_file_chooser($1,$2,$3)";
  proc fl_file_chooser_callback:Fl_FileChooserCallback = "fl_file_chooser_callback($1);";
  proc fl_file_chooser_ok_label:string = "fl_file_chooser_ok_label(const_cast<char *>(strdup($1.c_str())))";

}

@h2
 \class Fl_Text_Selection
 \brief This is an internal class for Fl_Text_Buffer to manage text selections.
 This class works correctly with utf-8 strings assuming that the parameters
 for all calls are on character boundaries.
@felix
typedef fl_text_selection = Fl_Text_Selection;
class Fl_Text_Selection {

  /**
   \brief Set the selection range.
   \param start byte offset to first selected character
   \param end byte offset pointing after last selected character
   */
  proc set: fl_text_selection*int*int = "$1->set($1, $2);";
  
  /**
   \brief Updates a selection afer text was modified.
   Updates an individual selection for changes in the corresponding text
   \param pos byte offset into text buffer at which the change occured
   \param nDeleted number of bytes deleted from the buffer
   \param nInserted number of bytes inserted into the buffer
   */
  proc update: fl_text_selection*int*int = "$1->update($2,$3,$4);";
  
  /**
   \brief Return the byte offset to the first selected character.
   \return byte offset
   */
  fun start: fl_text_selection->int = "$1->start()";
  
  /**
   \brief Return the byte ofsset to the character after the last selected character.
   \return byte offset
   */
  fun end: fl_text_selection->int = "$1->end()";
  
  /**
   \brief Returns true if any text is selected.
   \return a non-zero number if any text has been selected, or 0
   if no text is selected.
   */
  fun get_selected: fl_text_selection->bool = "$1->selected()";
  
  /**
   \brief Modify the 'selected' flag.
   \param b new flag
   */
  proc selected: fl_text_selection*bool = "$1->selected($2);";
  
  /**
   Return true if position \p pos with indentation \p dispIndex is in
   the Fl_Text_Selection.
   */
  fun includes: fl_text_selection*int->int = "$1->includes($2)";
  
  /**
   \brief Return the positions of this selection.
   \param start retrun byte offset to first selected character
   \param end retrun byte offset pointing after last selected character
   \return true if selected
   */
  fun position: fl_text_selection*int*int->int = "$1->position($2,$3)";
  
};


typedef fl_text_modify_cb = int*int*int*int*carray[char]*address-->void;
typedef fl_text_predelete_cb = int*int*address-->void;


/**
 \brief This class manages unicode displayed in one or more Fl_Text_Display widgets.
 
 All text in Fl_Text_Buffermust be encoded in UTF-8. All indices used in the 
 function calls must be aligned to the start of a UTF-8 sequence. All indices 
 and pointers returned will be aligned. All functions that return a single 
 character will return that in an unsiged int in UCS-4 encoding.
 
 The Fl_Text_Buffer class is used by the Fl_Text_Display
 and Fl_Text_Editor to manage complex text data and is based upon the
 excellent NEdit text editor engine - see http://www.nedit.org/.
 */
type fl_text_buffer = "Fl_Text_Buffer *";

class Fl_Text_Buffer {
  /**
   Create an empty text buffer of a pre-determined size.   
   \param requestedSize use this to avoid unnecessary re-allocation 
    if you know exactly how much the buffer will need to hold
   \param preferredGapSize Initial size for the buffer gap (empty space
    in the buffer where text might be inserted
    if the user is typing sequential chars)
   */
  ctor fl_text_buffer: int*int = "new Fl_Text_Buffer($1,$2)";
  ctor fl_text_buffer: int = "new Fl_Text_Buffer($1)";
  ctor fl_text_buffer: 1 = "new Fl_Text_Buffer()";

  /**
   \brief Returns the number of bytes in the buffer.
   \return size of text in bytes
   */

  fun length: fl_text_buffer->int = "$1->length()";
  
  /**
   \brief Get a copy of the entire contents of the text buffer.
   Memory is allocated to contain the returned string, which the caller 
   must free.
   \return newly allocated text buffer - must be free'd, text is utf8
   */  
  fun get_text: fl_text_buffer->string = "$1->text()";
  
  /**  
   Replaces the entire contents of the text buffer.
   \param text Text must be valid utf8.
   */
  proc text: fl_text_buffer = "$1->text(const_cast<char *>(strdup($2.c_str())))";
  
  /**
   \brief Get a copy of a part of the text buffer.
   Return a copy of the text between \p start and \p end character positions
   from text buffer \p buf. Positions start at 0, and the range does not
   include the character pointed to by \p end.
   When you are done with the text, free it using the free() function.
   \param start byte offset to first character
   \param end byte offset after last character in range
   \return newly allocated text buffer - must be free'd, text is utf8
   */
  fun text_range: fl_text_buffer*int*int->string = "$1->text_range($2,$3)";
  
  /**
   Returns the character at the specified position pos in the buffer.
   Positions start at 0 
   \param pos byte offset into buffer, pos must be at acharacter boundary
   \return Unicode UCS-4 encoded character
   */
  fun char_at: fl_text_buffer*int->uint = "$1->char_at($2)";
  
  /**
   Returns the raw byte at the specified position pos in the buffer.
   Positions start at 0 
   \param pos byte offset into buffer
   \return unencoded raw byte
   */
  fun byte_at: fl_text_buffer*int->char = "$1->byte_at($2)";
  
  /**
   Convert a byte offset in buffer into a memory address.
   \param pos byte offset into buffer
   \return byte offset converted to a memory address
   */
  fun get_address: fl_text_buffer*int->carray[char] = "$1->address($2)";
  
  /**
   Convert a byte offset in buffer into a memory address.
   \param pos byte offset into buffer
   \return byte offset converted to a memory address
   */
  //char *address(int pos)
  //{ return (pos < mGapStart) ? mBuf+pos : mBuf+pos+mGapEnd-mGapStart; }
  
  /** 
   Inserts null-terminated string \p text at position \p pos. 
   \param pos insertion position as byte offset (must be utf-8 character aligned)
   \param text utf-8 encoded and nul terminated text
   */
  proc insert: fl_text_buffer*int*string = "$1->insert($2,const_char<char *>(strdup($3.c_str())));";
  
  /**
   Appends the text string to the end of the buffer.  
   \param t utf-8 encoded and nul terminated text
   */
  proc append: fl_text_buffer*string = "$1->append(const_cast<char *>(strdup($2.c_str())));";
  
  /**
   Deletes a range of characters in the buffer.
   \param start byte offset to first character to be removed
   \param end byte offset to charcatre after last character to be removed
   */
  proc dremove: fl_text_buffer*int*int = "$1->remove($1,$2);";
  
  /**
   Deletes the characters between \p start and \p end, and inserts the null-terminated string \p text in their place in the buffer.
   \param start byte offset to first character to be removed and new insert position
   \param end byte offset to charcatre after last character to be removed
   \param text utf-8 encoded and nul terminated text
   */
  proc replace: fl_text_buffer*int*int*string = "$1->replace($2,$3,const_cast<char *>(strdup($4.c_str())))";
  
  /**
   Copies text from one buffer to this one.
   \param fromBuf source text buffer may be the same as this
   \param fromStart byte offset into buffer
   \param fromEnd byte offset into buffer
   \param toPos destination byte offset into buffer
   */
  proc copy: fl_text_buffer*fl_text_buffer*int*int*int = "$1->copy($2,$3,$4,$5);";
  
  /**
   Undo text modification according to the undo variables or insert text 
   from the undo buffer
   */
  fun undo: fl_text_buffer*int->int = "$1->undo($1)";
  fun undo: fl_text_buffer*int->int = "$1->undo()";
  
  /** 
   Lets the undo system know if we can undo changes 
   */
  proc canUndo: fl_text_buffer*char = "$1->canUndo($2);";
  proc canUndo: fl_text_buffer*char = "$1->canUndo();";
  
  /**
   Inserts a file at the specified position. Returns 0 on success, 
   non-zero on error (strerror() contains reason).  1 indicates open 
   for read failed (no data loaded). 2 indicates error occurred 
   while reading data (data was partially loaded).
   File can be UTF-8 or CP1252-encoded.
   If the input file is not UTF-8-encoded, the Fl_Text_Buffer widget will contain
   UTF-8-transcoded data. By default, the message Fl_Text_Buffer::file_encoding_warning_message
   will warn the user about this.
   \see input_file_was_transcoded and transcoding_warning_action.
   */
  fun insertfile: fl_text_buffer*string*int*int->int = "$1->insertfile(const_cast<char *>(strdup($2.c_str())),$3,$4)";
    fun insertfile: fl_text_buffer*string*int->int = "$1->insertfile(const_cast<char *>(strdup($2.c_str())),$3)";
  
  /**
   Appends the named file to the end of the buffer. See also insertfile().
   */
  fun appendfile: fl_text_buffer*string*int->int = "$1->appendfile(const_cast<char *>($2.c_str()),$3)";
  
  /** 
   Loads a text file into the buffer. See also insertfile().
   Args filename bufferlen=128*1024
   */
  fun loadfile: fl_text_buffer*string*int->int = "$1->loadfile(const_cast<char *>(strdup($2.c_str())),$3)";
  fun loadfile: fl_text_buffer*string*int->int = "$1->loadfile(const_cast<char *>(strdup($2.c_str())))";

  
  /**
   Writes the specified portions of the file to a file. Returns 0 on success, non-zero 
   on error (strerror() contains reason).  1 indicates open for write failed 
   (no data saved). 2 indicates error occurred while writing data 
   (data was partially saved).
   */
  fun outputfile: fl_text_buffer*string*int*int*int->int = "$1->outputfile(const_cast<char *>(strdup($2.c_str())),$3,$4,$5)";
  fun outputfile: fl_text_buffer*string*int*int->int = "$1->outputfile(const_cast<char *>(strdup($2.c_str())),$3,$4)";
  
  /** 
   Saves a text file from the current buffer 
   */
  fun savefile: fl_text_buffer*string*int->int = "$1->savefile(const_cast<char *>(strdup($2.c_str())),$3)";
  
  /**
   Gets the tab width.  
   */
  fun get_tab_distance: fl_text_buffer->int = "$1->tab_distance()";
  
  /**
   Set the hardware tab distance (width) used by all displays for this buffer,
   and used in computing offsets for rectangular selection operations.
   */
  proc tab_distance: fl_text_buffer*int = "$1->tab_distance($2);";
  
  /**  
   Selects a range of characters in the buffer.
   */
  proc select: fl_text_buffer*int*int = "$1->select($2,$3)";
  
  /** 
   Returns a non 0 value if text has been selected, 0 otherwise 
   */
  fun selected: fl_text_buffer->int = "$1->selected()";
  
  /** 
   Cancels any previous selection on the primary text selection object 
   */
  proc unselect: fl_text_buffer = "$1->unselect();";
  
  /** 
   Gets the selection position 
   */
  fun selection_position: fl_text_buffer*&int*&int->int = "$1->selection_position($2,$3)";
  
  /** 
   Returns the currently selected text. When you are done with
   the text, free it using the free() function.
   */
  fun selection_text: fl_text_buffer->string = "$1->selection_text()";

  /**  
   Removes the text in the primary selection.
   */
  proc remove_selection: fl_text_buffer = "$1->remove_selection();";
  
  /**
   Replaces the text in the primary selection.
   */
  proc replace_selection: fl_text_buffer*string = "$1->replace_selection(const_cast<char *>(strdup($2.c_str())));";
  
  /**
   Selects a range of characters in the secondary selection.
   */
  proc secondary_select: fl_text_buffer*int*int = "$1->secondary_select($2,$3);";
  
  /** 
   Returns a non 0 value if text has been selected in the secondary
   text selection, 0 otherwise 
   */
  fun secondary_selected: fl_text_buffer->int = "$1->secondary_selected()";
  
  /** 
   Clears any selection in the secondary text selection object. 
   */
  proc secondary_unselect: fl_text_buffer = "$1->secondary_unselect();";
  
  /** 
   Returns the current selection in the secondary text selection object.
   */
  fun secondary_selection_position: fl_text_buffer*&int*&int->int = "$1->secondary_selection_position($2, $3)";
  
  /** 
   Returns the text in the secondary selection. When you are
   done with the text, free it using the free() function.
   */
  fun secondary_selection_text: fl_text_buffer->string = "$1->secondary_selection_text()";
  
  /**  
   Removes the text from the buffer corresponding to the secondary text selection object.
   */
  proc remove_secondary_selection: fl_text_buffer = "$1->remove_secondary_selection();";
  
  /**  
   Replaces the text from the buffer corresponding to the secondary 
   text selection object with the new string \p text.
   */
  proc replace_secondary_selection: fl_text_buffer*string = "$1->replace_secondary_selection(const_cast<char *>(strdup($2.c_str())));";
  
  /**  
   Highlights the specified text within the buffer.
   */
  proc highlight: fl_text_buffer*int*int = "$1->highlight($2,$3);";
  
  /**
   Returns the highlighted text. When you are done with the
   text, free it using the free() function.
   */
  fun get_highlight: fl_text_buffer->int = "$1->highlight()";
  
  /**
   Unhighlights text in the buffer.
   */
  proc unhighlight: fl_text_buffer = "$1->unhighlight();";

  /** 
   Highlights the specified text between \p start and \p end within the buffer.
   */
  fun highlight_position: fl_text_buffer*&int*&int->int = "$1->highlight_position($2,$3)";
  
  /** 
   Returns the highlighted text. When you are done with the
   text, free it using the free() function.
   */
  fun highlight_text: fl_text_buffer->string = "$1->highlight_text();";
  
  /**
   Adds a callback function that is called whenever the text buffer is
   modified. The callback function is declared as follows:
   
   \code
   typedef void (*Fl_Text_Modify_Cb)(int pos, int nInserted, int nDeleted,
      int nRestyled, const char* deletedText,
      void* cbArg);
   \endcode
   */
  proc add_modify_callback: fl_text_buffer*fl_text_modify_cb*address = "$1->add_modify_callback($2,$3);";  
  /**
   Removes a modify callback.
   */
  proc remove_modify_callback: fl_text_buffer*fl_text_modify_cb*address = "$1->remove_modify_callback($2,$3);";
  
  /**
   Calls all modify callbacks that have been registered using
   the add_modify_callback()
   method.
   */
  proc call_modify_callbacks: fl_text_buffer = "$1->call_modify_callbacks();";
  
  /** 
   Adds a callback routine to be called before text is deleted from the buffer. 
   */
  proc add_predelete_callback: fl_text_buffer*fl_text_predelete_cb*address = "$1->add_predelete_callback($2,$3);";
  /** 
   Removes a callback routine \p bufPreDeleteCB associated with argument \p cbArg 
   to be called before text is deleted from the buffer. 
   */
  proc remove_predelete_callback: fl_text_buffer*fl_text_predelete_cb*address = "$1->remove_predelete_callback($2,$3);";
  
  /**
   Calls the stored pre-delete callback procedure(s) for this buffer to update 
   the changed area(s) on the screen and any other listeners.
   */
  proc call_predelete_callbacks: fl_text_buffer = "$1->call_predelete_callbacks();";
  
  /**
   Returns the text from the entire line containing the specified
   character position. When you are done with the text, free it
   using the free() function.
   \param pos byte index into buffer
   \return copy of utf8 text, must be free'd
   */
  fun line_text: fl_text_buffer*int->string = "$1->line_text($2)";
  
  /** 
   Returns the position of the start of the line containing position \p pos. 
   \param pos byte index into buffer
   \return byte offset to line start
   */
  fun line_start: fl_text_buffer*int->int = "$1->line_start($2)";
  
  /** 
   Finds and returns the position of the end of the line containing position \p pos
   (which is either a pointer to the newline character ending the line,
   or a pointer to one character beyond the end of the buffer)
   \param pos byte index into buffer
   \return byte offset to line end
   */
  fun line_end: fl_text_buffer*int->int = "$1->line_end($2)";

  /** 
   Returns the position corresponding to the start of the word 
   \param pos byte index into buffer
   \return byte offset to word start
   */
  fun word_start: fl_text_buffer*int->int = "$1->word_start($2)";

  /**  
   Returns the position corresponding to the end of the word.
   \param pos byte index into buffer
   \return byte offset to word end
   */
  fun word_end: fl_text_buffer*int->int = "$1->word_end($2)";
  
  /**
   Count the number of displayed characters between buffer position
   \p lineStartPos and \p targetPos. (displayed characters are the characters
   shown on the screen to represent characters in the buffer, where tabs and
   control characters are expanded)
   */
  fun cound_displayed_characters: fl_text_buffer*int*int->int ="$1->count_displayed_characters($2,$3)";

  /**
   Count forward from buffer position \p startPos in displayed characters
   (displayed characters are the characters shown on the screen to represent
   characters in the buffer, where tabs and control characters are expanded)
   \param lineStartPos byte offset into buffer
   \param nChars number of bytes that are sent to the display
   \return byte offset in input after all output bytes are sent
   */
  fun skip_displayed_characters: fl_text_buffer*int*int->int = "$1->skip_displayed_characters($2,$3)";
  
  /**
   Counts the number of newlines between \p startPos and \p endPos in buffer.
   The character at position \p endPos is not counted.
   */
  fun count_lines: fl_text_buffer*int*int->int = "$1->count_lines($2,$3)";

  /**
   Finds the first character of the line \p nLines forward from \p startPos
   in the buffer and returns its position
   */
  fun skip_lines: fl_text_buffer*int*int->int = "$1->skip_lines($2,$3)";
  
  /**
   Finds and returns the position of the first character of the line \p nLines backwards
   from \p startPos (not counting the character pointed to by \p startpos if
   that is a newline) in the buffer.  \p nLines == 0 means find the beginning of the line
   */
  fun rewind_lines: fl_text_buffer*int*int->int = "$1->rewind_lines($2,$3)";

  /** 
   Finds the next occurrence of the specified character.
   Search forwards in buffer for character \p searchChar, starting
   with the character \p startPos, and returning the result in \p foundPos
   returns 1 if found, 0 if not.  (The difference between this and
   BufSearchForward is that it's optimized for single characters.  The
   overall performance of the text widget is dependent on its ability to
   count lines quickly, hence searching for a single character: newline)
   \param startPos byte offset to start position
   \param searchChar UCS-4 character that we want to find
   \param foundPos byte offset where the character was found
   \return 1 if found, 0 if not
   */
  fun findchar_forward: fl_text_buffer*int*uint*&int->int = "$1->findchar_backward($2,$3,$4)";
  
  /**
   Search backwards in buffer \p buf for character \p searchChar, starting
   with the character BEFORE \p startPos, returning the result in \p foundPos
   returns 1 if found, 0 if not.  (The difference between this and
   BufSearchBackward is that it's optimized for single characters.  The
   overall performance of the text widget is dependent on its ability to
   count lines quickly, hence searching for a single character: newline)
   \param startPos byte offset to start position
   \param searchChar UCS-4 character that we want to find
   \param foundPos byte offset where the character was found
   \return 1 if found, 0 if not
   */
  fun findchar_backward: fl_text_buffer*int*uint*&int->int = "$1->findchar_backward($2,$3,$4)";
  
  /**
   Search forwards in buffer for string \p searchString, starting with the
   character \p startPos, and returning the result in \p foundPos
   returns 1 if found, 0 if not.
   \param startPos byte offset to start position
   \param searchString utf8 string that we want to find
   \param foundPos byte offset where the string was found
   \param matchCase if set, match character case
   \return 1 if found, 0 if not
   */
  fun search_forward: fl_text_buffer*int*string*int*int->int = "$1->search_backward($21,const_cast<char *>(strdup($3.c_str())),$4,$5)";
  fun search_forward: fl_text_buffer*int*string*int->int = "$1->search_backward($21,const_cast<char *>(strdup($3.c_str())),$4)";
  
  /**
   Search backwards in buffer for string <i>searchCharssearchString</i>, starting with the
   character BEFORE \p startPos, returning the result in \p foundPos
   returns 1 if found, 0 if not.
   \param startPos byte offset to start position
   \param searchString utf8 string that we want to find
   \param foundPos byte offset where the string was found
   \param matchCase if set, match character case
   \return 1 if found, 0 if not
   */
  fun search_backward: fl_text_buffer*int*string*int*int->int = "$1->search_backward($21,const_cast<char *>(strdup($3.c_str())),$4,$5)";
  fun search_backward: fl_text_buffer*int*string*int->int = "$1->search_backward($21,const_cast<char *>(strdup($3.c_str())),$4)";
  
  /** 
   Returns the primary selection.  
   */
  //const Fl_Text_Selection* primary_selection() const { return &mPrimary; }
  
  /**
   Returns the primary selection. 
   */
  fun primary_selection: fl_text_buffer->fl_text_selection ="$1->primary_selection()";
  
  /**
   Returns the secondary selection.
   */
  fun secondary_selection: fl_text_buffer->fl_text_selection = "$1->secondary_selection()";
  
  /**
   Returns the current highlight selection.
   */
  fun highlight_selection: fl_text_buffer->fl_text_selection = "$1->highlight_selection()";
  
  /**
   Returns the index of the previous character.
   \param ix index to the current char
   */
  fun prev_char: fl_text_buffer*int->int = "$1->prev_char($2)";
  fun prev_char_clipped: fl_text_buffer*int->int = "$1->prev_char_clipped($2)";
  
  /**
   Returns the index of the next character.
   \param ix index to the current char
   */
  fun next_char: fl_text_buffer*int->int = "$1->next_char($2)";
  fun next_char_clipped: fl_text_buffer*int->int = "$1->next_char_clipped($2)";
  
  /**
   Align an index into the buffer to the current or previous utf8 boundary.
   */
  fun utf8_align:fl_text_buffer*int->int = "$1->utf8_align($2)";
  
  /**
   \brief true iff the loaded file has been transcoded to UTF-8
   */
  fun input_file_was_transcoded: fl_text_buffer->bool ="$1->input_file_was_transcoded()";

  /** This message may be displayed using the fl_alert() function when a file
   which was not UTF-8 encoded is input.
   */
  const file_encoding_warning_message:carray[char];
  /** 
   \brief Pointer to a function called after reading a non UTF-8 encoded file.
   
   This function is called after reading a file if the file content
   was transcoded to UTF-8. Its default implementation calls fl_alert()
   with the text of \ref file_encoding_warning_message. No warning message is
   displayed if this pointer is set to NULL. Use \ref input_file_was_transcoded
   to be informed if file input required transcoding to UTF-8.
   */
  //void (*transcoding_warning_action)(Fl_Text_Buffer*);
  

};



/**
  This is the FLTK text editor widget. It allows the user to
  edit multiple lines of text and supports highlighting and
  scrolling. The buffer that is displayed in the widget is managed
  by the Fl_Text_Buffer
  class.
*/

class Fl_Text_Editor /* Fl_Text_Display*/ {
  const FL_TEXT_EDITOR_ANY_STATE:long;
    /** Key function binding callback type */
    typedef key_func = int*fl_text_editor-->int;
    /** Simple linked list associating a key/state to a function */
    cstruct Key_Binding {
      key:int;		///< the key pressed
      state:int;	///< the state of key modifiers
      function:key_func;///< associated function
      next:Key_Binding; ///< next key binding in the list
    };
    typedef key_binding = Key_Binding;

    
    ctor fl_text_editor: int*int*int*int*string = "new Fl_Text_Editor($2,$3,$4,$5,const_cast<char *>(strdup($6.c_str())))";
    ctor fl_text_editor: int*int*int*int*string = "new Fl_Text_Editor($2,$3,$4,$5)";
    fun handle: fl_text_editor*int->int = "handle($2)";
    /**
	Sets the current insert mode; if non-: fl_text_Editorzero, new text
	is inserted before the current cursor position. Otherwise, new
	text replaces text at the current cursor position.
    */
    proc insert_mode: fl_text_editor*int = "$1->insert_mode($2);";
    /**
	Gets the current insert mode; if non-zero, new text
	is inserted before the current cursor position. Otherwise, new
	text replaces text at the current cursor position.
    */
    fun insert_mode: fl_text_editor->int = "$1->insert_mode()";

    proc add_key_binding: fl_text_editor*int*int*key_func*carray[key_binding] =  "$1->add_key_binding($2,$3,$4,$5);";
    /** Adds a key of state "state" with the function "function" */
    proc add_key_binding: fl_text_editor*int*int*key_func = "$1->add_key_binding($2,$3,$4);";
    proc remove_key_binding: fl_text_editor*int*int*carray[key_binding] = "$1->remove_key_binding($2,$3,$4);";
    /** Removes the key binding associated with the key "key" of state "state". */
    proc remove_key_binding: fl_text_editor*int*int = "$1->remove_key_binding($2,$3);";
    proc remove_all_key_bindings: fl_text_editor*carray[key_binding] = "$1->remove_all_key_bindings($2);";
    /** Removes all of the key bindings associated with the text editor or list. */
    proc remove_all_key_bindings: fl_text_editor = "$1->remove_all_key_bindings()";
    proc add_default_key_bindings: fl_text_editor*carray[key_binding] = "$1->add_default_key_bindings($2);"; 
    fun bound_key_function: fl_text_editor*int*int*carray[key_binding]->key_func = "$1->bound_key_function($2,$3,$4)";
    /**  Returns the function associated with a key binding. */
    fun bound_key_function: fl_text_editor*int*int->key_func = "$1->bound_key_function($2,$3)";
    /**  Sets the default key function for unassigned keys. */
    proc default_key_function: fl_text_editor*key_func  = "$1->default_key_function($2);";

    // functions for the built in default bindings
    fun kf_default: int*fl_text_editor->int = "Fl_Text_Editor::kf_default($1,$2)";
    fun kf_ignore: int*fl_text_editor->int = "Fl_Text_Editor::kf_ignore($1,$2)";
    fun kf_backspace: int*fl_text_editor->int = "Fl_Text_Editor::kf_backspace($1,$2)";
    fun kf_enter: int*fl_text_editor->int = "Fl_Text_Editor::kf_enter($1,$2)";
    fun kf_move: int*fl_text_editor->int = "Fl_Text_Editor::kf_move($1,$2)";
    fun kf_shift_move: int*fl_text_editor->int = "Fl_Text_Editor::kf_shift_move($1,$2)";
    fun kf_ctrl_move: int*fl_text_editor->int = "Fl_Text_Editor::kf_ctrl_move($1,$2)";
    fun kf_c_s_move: int*fl_text_editor->int = "Fl_Text_Editor::kf_c_s_move($1,$2)";
    fun kf_meta_move: int*fl_text_editor->int = "Fl_Text_Editor::kf_meta_move($1,$2)";
    fun kf_m_s_move: int*fl_text_editor->int = "Fl_Text_Editor::kf_m_s_move($1,$2)";
    fun kf_home: int*fl_text_editor->int = "Fl_Text_Editor::kf_home($1,$2)";
    fun kf_end: int*fl_text_editor->int = "Fl_Text_Editor::kf_end($1,$2)";
    fun kf_left: int*fl_text_editor->int = "Fl_Text_Editor::kf_left($1,$2)";
    fun kf_up: int*fl_text_editor->int = "Fl_Text_Editor::kf_up($1,$2)";
    fun kf_right: int*fl_text_editor->int = "Fl_Text_Editor::kf_right($1,$2)";
    fun kf_down: int*fl_text_editor->int = "Fl_Text_Editor::kf_down($1,$2)";
    fun kf_page_up: int*fl_text_editor->int = "Fl_Text_Editor::kf_page_up($1,$2)";
    fun kf_page_down: int*fl_text_editor->int = "Fl_Text_Editor::kf_page_down($1,$2)";
    fun kf_insert: int*fl_text_editor->int = "Fl_Text_Editor::kf_insert($1,$2)";
    fun kf_delete: int*fl_text_editor->int = "Fl_Text_Editor::kf_delete($1,$2)";
    fun kf_copy: int*fl_text_editor->int = "Fl_Text_Editor::kf_copy($1,$2)";
    fun kf_cut: int*fl_text_editor->int = "Fl_Text_Editor::kf_cut($1,$2)";
    fun kf_paste: int*fl_text_editor->int = "Fl_Text_Editor::kf_paste($1,$2)";
    fun kf_select_all: int*fl_text_editor->int = "Fl_Text_Editor::kf_select_all($1,$2)";
    fun kf_undo: int*fl_text_editor->int = "Fl_Text_Editor::kf_undo($1,$2)";
};

/**
  \class Fl_Native_File_Chooser

  This class lets an FLTK application easily and consistently access 
  the operating system's native file chooser. Some operating systems 
  have very complex and specific file choosers that many users want 
  access to specifically, instead of FLTK's default file chooser(s). 

  In cases where there is no native file browser, FLTK's own file browser
  is used instead.

  To use this widget correctly, use the following include in your code:
  \code
  #include <FL/Fl_Native_File_Chooser.H>
  \endcode
  Do not include the other Fl_Native_File_Choser_XXX.H files in your code;
  those are platform specific files that will be included automatically
  depending on your build platform.

  The following example shows how to pick a single file:
  \code
  // Create and post the local native file chooser
  #include <FL/Fl_Native_File_Chooser.H>
  [..]
  Fl_Native_File_Chooser fnfc;
  fnfc.title("Pick a file");
  fnfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
  fnfc.filter("Text\t*.txt\n"
              "C Files\t*.{cxx,h,c}");
  fnfc.directory("/var/tmp");           // default directory to use
  // Show native chooser
  switch ( fnfc.show() ) {
    case -1: printf("ERROR: %s\n", fnfc.errmsg());    break;  // ERROR
    case  1: printf("CANCEL\n");                      break;  // CANCEL
    default: printf("PICKED: %s\n", fnfc.filename()); break;  // FILE CHOSEN
  }
  \endcode

  <B>Platform Specific Caveats</B>

  - Under X windows, it's best if you call Fl_File_Icon::load_system_icons()
    at the start of main(), to enable the nicer looking file browser widgets.
    Use the static public attributes of class Fl_File_Chooser to localize
    the browser.
  - Some operating systems support certain OS specific options; see 
    Fl_Native_File_Chooser::options() for a list.

  \image html Fl_Native_File_Chooser.png "The Fl_Native_File_Chooser on different platforms."
  \image latex Fl_Native_File_Chooser.png "The Fl_Native_File_Chooser on different platforms" width=14cm

*/


/* \file
 Fl_Native_File_Chooser widget. */
/**
 This class lets an FLTK application easily and consistently access 
 the operating system's native file chooser. Some operating systems 
 have very complex and specific file choosers that many users want 
 access to specifically, instead of FLTK's default file chooser(s). 
 
 In cases where there is no native file browser, FLTK's own file browser
 is used instead.
 
 To use this widget, use the following include in your code:
 \code
 #include <FL/Fl_Native_File_Chooser.H>
 \endcode
 
 The following example shows how to pick a single file:
 \code
 // Create and post the local native file chooser
 #include <FL/Fl_Native_File_Chooser.H>
 [..]
 Fl_Native_File_Chooser fnfc;
 fnfc.title("Pick a file");
 fnfc.type(Fl_Native_File_Chooser::BROWSE_FILE);
 fnfc.filter("Text\t*.txt\n"
             "C Files\t*.{cxx,h,c}");
 fnfc.directory("/var/tmp");           // default directory to use
 // Show native chooser
 switch ( fnfc.show() ) {
   case -1: printf("ERROR: %s\n", fnfc.errmsg());    break;  // ERROR
   case  1: printf("CANCEL\n");                      break;  // CANCEL
   default: printf("PICKED: %s\n", fnfc.filename()); break;  // FILE CHOSEN
 }
 \endcode
 
 <B>Platform Specific Caveats</B>
 
 - Under X windows, it's best if you call Fl_File_Icon::load_system_icons()
 at the start of main(), to enable the nicer looking file browser widgets.
 Use the static public attributes of class Fl_File_Chooser to localize
 the browser.
 - Some operating systems support certain OS specific options; see 
 Fl_Native_File_Chooser::options() for a list.
 
 \image html Fl_Native_File_Chooser.png "The Fl_Native_File_Chooser on different platforms."
 \image latex Fl_Native_File_Chooser.png "The Fl_Native_File_Chooser on different platforms" width=14cm
 
 */

//


class Fl_Native_File_Chooser {

  cenum Type =
    BROWSE_FILE,			///< browse files (lets user choose one file)
    BROWSE_DIRECTORY,			///< browse directories (lets user choose one directory)
    BROWSE_MULTI_FILE,			///< browse files (lets user choose multiple files)
    BROWSE_MULTI_DIRECTORY,		///< browse directories (lets user choose multiple directories)
    BROWSE_SAVE_FILE,			///< browse to save a file
    BROWSE_SAVE_DIRECTORY;		///< browse to save a directory
  
  cenum Option =
    NO_OPTIONS, //     = 0x0000,		///< no options enabled
    SAVEAS_CONFIRM, // = 0x0001,		///< Show native 'Save As' overwrite confirm dialog (if supported)
    NEW_FOLDER, //     = 0x0002,		///< Show 'New Folder' icon (if supported)
    PREVIEW; //        = 0x0004		///< enable preview mode
  
  /** Localizable message */
  fun get_file_exists_message: 1->string = "Fl_Native_File_Chooser::file_exists_message";
  fun set_file_exists_message: 1->string = "Fl_Native_File_Chooser::file_exists_message = const_cast<char *>(strdup($1.c_str()));";

  ctor fl_native_file_chooser: int = "new Fl_Native_File_Chooser($1)";
  ctor fl_native_file_chooser: 1 = "new Fl_Native_File_Chooser()";

  proc set_type: fl_native_file_chooser*int = "$1->type(int);";
  fun get_type: fl_native_file_chooser->int = "$1->type()";
  proc options: fl_native_file_chooser*int = "$1->options(int);";
  fun get_options: fl_native_file_chooser->int = "$1->options()";
  fun count: fl_native_file_chooser->int = "$1->count($2)";

  fun filename: fl_native_file_chooser->string = "$1->filename()";
  fun filename: fl_native_file_chooser*int->string = "$1->filename($2)";
  proc directory: fl_native_file_chooser*string = "$1->proc directory(const_cast<char *>(strdup($2.c_str())));";
  fun get_directory: fl_native_file_chooser->string = "$1->directory()";
  proc title: fl_native_file_chooser*string = "$1->proc title($2);";
  fun get_title: fl_native_file_chooser->string = "$1->title()";
  fun get_filter: fl_native_file_chooser->string = "$1->filter()";
  proc filter: fl_native_file_chooser*string = "$1->proc filter(const_cast<char *>(strdup($2.c_str())));";
  fun filters: fl_native_file_chooser->int = "$1->filters()";
  proc filter_value: fl_native_file_chooser*int = "$1->filter_value($2);";
  fun  filter_value: fl_native_file_chooser->int = "$1->filter_value()";
  proc preset_file: fl_native_file_chooser*string = "$1->preset_file(const_cast<char *>(strdup($2.c_str())));";
  fun preset_file: fl_native_file_chooser->string = "$1->preset_file()";
  fun errmsg: fl_native_file_chooser->string = "$1->errmsg()";
  fun show: fl_native_file_chooser->int = "$1->int show()";

};

class Fl_Ask {

  const FL_BEEP_DEFAULT:int;
  const FL_BEEP_MESSAGE:int;
  const FL_BEEP_ERROR:int;
  const FL_BEEP_QUESTION:int;
  const FL_BEEP_PASSWORD:int;
  const FL_BEEP_NOTIFICATION:int;

  proc fl_beep: int = "fl_beep($1);";
  proc fl_beep: int = "fl_beep();";
  proc fl_message: string = "fl_message(const_cast<char *>(strdup($1.c_str())));";
  proc fl_alert: string = "fl_alert(const_cast<char *>(strdup($1.c_str())));";
  fun fl_ask: string->int = "fl_ask(const_cast<char *>(strdup($1.c_str())))";
  fun fl_choicd: string*string*string->int = "fl_alert(const_cast<char *>(strdup($1.c_str())),const_cast<char *>(strdup($2.c_str())),const_cast<char *>(strdup($3.c_str())),const_cast<char *>(strdup($4.c_str())))";

  fun fl_input: string*string->string = "fl_input(const_cast<char *>(strdup($1.c_str())),const_cast<char *>(strdup($2.c_str())))";
  fun fl_input: string->string = "fl_input(const_cast<char *>(strdup($1.c_str())))";
  fun fl_passwd: string->string = "fl_passwd(const_cast<char *>(strdup($1.c_str())))";

  fun fl_message_icon: 1->fl_widget = "fl_message_icon()";
  fun get_fl_message_font: 1->fl_font = "fl_message_font()";
  fun fl_message_size: 1->fl_fontsize = "fl_message_size()";
  proc fl_message_font: fl_font*fl_fontsize  = "fl_message_font($1,$2);";

  proc fl_message_hotspot: int = "fl_message_hotspot($1);";
  fun fl_message_hotspot: 1->int = "fl_message_hotspot();";

  proc fl_message_title: string = "fl_message_title(const_cast<char *>(strdup($1.c_str())));";
  proc fl_message_title_default: string = "fl_message_title_default(const_cast<char *>(strdup($1.c_str())));";

  proc set_fl_no: string = "fl_no = const_cast<char *>(strdup($1.c_str()));";
  proc set_fl_yes: string = "fl_yes = const_cast<char *>(strdup($1.c_str()));";
  proc set_fl_ok: string = "fl_ok = const_cast<char *>(strdup($1.c_str()));";
  proc set_fl_cancel: string = "fl_cancel = const_cast<char *>(strdup($1.c_str()));";
  proc set_fl_close: string = "fl_close = const_cast<char *>(strdup($1.c_str()));";
}

/**
 \brief Rich text display widget.
 
 This is the FLTK text display widget. It allows the user to view multiple lines
 of text and supports highlighting and scrolling. The buffer that is displayed 
 in the widget is managed by the Fl_Text_Buffer class. A single Text Buffer
 can be displayed by multiple Text Displays.
 */
class Fl_Text_Display[T in Fl_Text_Displays] {

  /** 
   text display cursor shapes enumeration 
   */
  cenum fl_text_display_cursors =
    NORMAL_CURSOR,    /**< I-beam */
    CARET_CURSOR,     /**< caret under the text */
    DIM_CURSOR,       /**< dim I-beam */
    BLOCK_CURSOR,     /**< unfille box under the current character */
    HEAVY_CURSOR;      /**< thick I-beam */
  
  /**
   the character position is the left edge of a character, whereas 
   the cursor is thought to be between the centers of two consecutive
   characters.
   */
  cenum pos_type =
    CURSOR_POS, 
    CHARACTER_POS;
  
  
  /** 
   drag types - they match Fl::event_clicks() so that single clicking to
   start a collection selects by character, double clicking selects by
   word and triple clicking selects by line.
   */
  const DRAG_NONE:int;
  const DRAG_START_DND:int;
  const DRAG_CHAR:int;
  const DRAG_WORD:int;
  const DRAG_LINE:int;
  
  
  /**
   wrap types - used in wrap_mode()
   */
  cenum wrap_types =
    WRAP_NONE,      /**< don't wrap text at all */
    WRAP_AT_COLUMN, /**< wrap text at the given text column */
    WRAP_AT_PIXEL,  /**< wrap text at a pixel position */
    WRAP_AT_BOUNDS;  /**< wrap text so that it fits into the widget width */
 
  
  //friend void fl_text_drag_me(int pos, Fl_Text_Display* d);
  
  typedef unfinished_style_cb = int*address-->void;
  
  /** 
   This structure associates the color, font, andsize of a string to draw
   with an attribute mask matching attr
   */
  cstruct Style_Table_Entry {
    color:fl_color;
    font:fl_font;
    size:fl_fontsize;
    attr:uint;
  };
  typedef style_table_entry = Style_Table_Entry;
  ctor style_table_entry(c:fl_color,f:fl_font,s:fl_fontsize) => Style_Table_Entry(c,f,s,0u);
  ctor fl_text_display: int*int*int*int*string = "Fl_Text_Display($1,$2,$3,$4,const_cast<char *>(strdup($5)))";
  ctor fl_text_display: int*int*int*int = "Fl_Text_Display($1,$2,$3,$4)";
  
  fun handle:T*int->int = "$1->handle($2)";
  
  proc buffer: T*fl_text_buffer ="$1->buffer($2);";
  
  /**
   Sets the current text buffer associated with the text widget.
   Multiple text widgets can be associated with the same text buffer.
   \param buf new text buffer
   */
  //proc buffer(Fl_Text_Buffer& buf) { buffer(&buf); }
  
  /**
   Gets the current text buffer associated with the text widget.
   Multiple text widgets can be associated with the same text buffer.
   \return current text buffer
   */
  fun get_buffer: T->fl_text_buffer = "$1->buffer();";
  
  proc redisplay_range: T*int*int = "$1->redisplay_range($2,$3);";
  proc scroll: T*int*int = "$1->scroll($2,$3);";
  proc insert: T*string = "$1->insert(const_cast<char *>(strdup($2.c_str())));";
  proc overstrike: T*string = "$1->overstrike(const_cast<char *>(strdup($2.c_str())));";
  proc insert_position: T*int = "$1->insert_position($2);";
  
  /** 
   Gets the position of the text insertion cursor for text display.
   \return insert position index into text buffer 
   */
  fun get_insert_position: T->int = "$1->insert_position()";
  fun position_to_xy: T*int*int->int = "$1->position_to($2,$3)";

  fun in_selection: T*int*int->int = "$1->in_selection($1,$2)";
  proc show_insert_position: T = "$1->show_insertion_position();";
  
  fun move_right: T->int = "$1->move_right()";
  fun move_left: T->int = "$1->move_left()";
  fun move_up: T->int = "$1->move_up()";  
  fun move_down: T->int = "$1->move_down()";
  fun count_lines: T*int*int*bool->int = "$1->count_lines($2,$3,$4)";
  fun line_start: T*int->int = "$1->line_start($2)";
  fun line_end: T*int*bool->int = "$1->line_end($2,$3)";
  fun skip_lines: T*int*int*bool->int = "$1->skip_lines($2,$3,$4)";
  fun rewind_line: T*int*int->int = "$1->rewind_lines($2,$3)";
  proc next_word: T = "$1->next_word();";
  proc previous_word: T = "$1->previous_word();";

  proc show_cursor: T*int = "$1->show_cursor($2);";
  proc show_cursor: T = "$1->show_cursor();";

  
  /**
   Hides the text cursor.
   */
  proc hide_cursor: T = "$1->hide_cursor();";
  
  proc cursor_style: T*int = "$1->cursor_style($2);";
  
  /**
   Gets the text cursor color.  
   \return cursor color
   */
  fun get_cursor_color: T->fl_color = "$1->cursor_color()";
  
  /**    
   Sets the text cursor color.
   \param n new cursor color
   */
  proc cursor_color: T*fl_color = "$1->cursor_color($2);";
  
  /**   
   Gets the width/height of the scrollbars.
   /return width of scrollbars
   */
  fun get_scrollbar_width: T->int = "$1->scrollbar_width()";
  
  /**
   Sets the width/height of the scrollbars.
   \param W width of scrollbars
   */
  proc scrollbar_width: T*int = "$1->scrollbar_width($2);";
  
  /**
   Gets the scrollbar alignment type.
   \return scrollbar alignment
   */
  fun scrollbar_align: T->fl_align = "$1->scrollbar_align()";
  
  /**
   Sets the scrollbar alignment type.
   \param a new scrollbar alignment
   */
  proc scrollbar_align: T*fl_align = "$1->scrollbar_align($2);";
  
  /**
   Moves the insert position to the beginning of the current word.
   \param pos start calculation at this index
   \return beginning of the words
   */
  fun word_start: T*int->int = "$1->word_start($2)";
  
  /** 
   Moves the insert position to the end of the current word.
   \param pos start calculation at this index
   \return index of first character after the end of the word
   */
  fun word_end: T*int->int = "$1->word_end($2)";
  
  
  proc highlight_data: T*fl_text_buffer*carray[style_table_entry]*int*char*unfinished_style_cb*address = "$1->highlight_data($2,$3,$4,$5,$6,$7);";

  fun position_style: T*int*int*int->int = "$1->position_style($2,$3,$4)";
  
  /** 
   \todo FIXME : get set methods pointing on shortcut_ 
   have no effects as shortcut_ is unused in this class and derived! 
   \return the current shortcut key
   */
  fun shortcut: T->int = "$1->shortcut()";
  
  /**
   \todo FIXME : get set methods pointing on shortcut_ 
   have no effects as shortcut_ is unused in this class and derived! 
   \param s the new shortcut key
   */
  proc shortcut: T*int = "$1->shortcut($2);";
  
  /**
   Gets the default font used when drawing text in the widget.
   \return current text font face unless overridden by a style
   */
  fun get_textfont: T->fl_font = "$1->textfont()";
  
  /**
   Sets the default font used when drawing text in the widget.
   \param s default text font face
   */
  proc textfont: T*fl_font = "$1->textfont($2);";
  
  /**
   Gets the default size of text in the widget.
   \return current text height unless overridden by a style
   */
  fun get_textsize: T->fl_fontsize = "$1->textsize()";
  
  /**
   Sets the default size of text in the widget.
   \param s new text size
   */
  proc textsize: T*fl_fontsize = "$1->textsize($1)";
  
  /**
   Gets the default color of text in the widget.
   \return text color unless overridden by a style
   */
  fun textcolor: T->fl_color = "$1->textcolor()";
  
  /**
   Sets the default color of text in the widget.
   \param n new text color
   */
  proc textcolor: T*fl_color = "$1->textcolor($2);";
  
  fun wrapped_column: T*int*int->int = "$1->wrapped_column($2,$3)";
  fun wrapped_row: T*int->int = "$1->wrapped_row($2)";
  fun wrapped_mode: T*int*int->int = "$1->wrapped_mode($2,$3)";
  
  proc resize: T*int*int*int*int = "$1->resize($2,$3,$4,$5);";

  /**
   Convert an x pixel position into a column number.
   \param x number of pixels from the left margin
   \return an approximate column number based on the main font
   */
  fun x_to_col: T*double->double = "$1->double x_to_col($2)";
  
  /**
   Convert a column number into an x pixel position.
   \param col an approximate column number based on the main font
   \return number of pixels from the left margin to the left of an
	   average sized character
   */
  fun col_to_x: T*double->double = "$1->double col_to_x($2)";

};

class Fl_Math {
  const M_PI:double;
  const M_PI_2:double;
  const M_PI_4:double;
  const M_1_PI:double;
  const M_2_PI:double;
  const M_SQRT2:double;
  const M_SQRT1_2:double;
}

/**
  The Fl_Valuator class controls a single floating-point value
  and provides a consistent interface to set the value, range, and step,
  and insures that callbacks are done the same for every object.
  <P>There are probably more of these classes in FLTK than any others:
  <P ALIGN=CENTER>\image html  valuators.png</P> 
  \image latex   valuators.png "Valuators derived from Fl_Valuators" width=10cm
  <P>In the above diagram each box surrounds an actual subclass.  These
  are further differentiated by setting the type() of the widget t
  o the symbolic value labeling the widget.  
  The ones labelled "0" are the default versions with a type(0).  
  For consistency the symbol FL_VERTICAL is defined as zero.
*/
class Fl_Valuator [T in Fl_Valuators] {
    /**    Sets the minimum (a) and maximum (b) values for the valuator widget. */
    proc bounds: T*double*double = "$1->bounds($2, $3);";
    /**    Gets the minimum value for the valuator.  */
    fun get_minimum: T->double = "$1->minimum()";
    /**    Sets the minimum value for the valuator.  */
    proc minimum: T*double = "$1->minimum($2);";
    /**    Gets the maximum value for the valuator.  */
    fun get_maximum: T->double = "$1->maximum()";
    /**    Sets the maximum value for the valuator.  */
    proc maximum: T*double = "$1->maximum($2);";
  /**
    Sets the minimum and maximum values for the valuator. When
    the user manipulates the widget, the value is limited to this
    range. This clamping is done <I>after</I> rounding to the step
    value (this makes a difference if the range is not a multiple of
    the step).
    
    <P>The minimum may be greater than the maximum. This has the
    effect of "reversing" the object so the larger values
    are in the opposite direction. This also switches which end of
    the filled sliders is filled.</P>
    
    <P>Some widgets consider this a "soft" range.  This
    means they will stop at the range, but if the user releases and
    grabs the control again and tries to move it further, it is
    allowed.</P>
    
    <P>The range may affect the display. You must redraw()
    the widget after changing the range.
  */
  proc range: T*double*double = "$1->range($2,$3);";
  /**    See double Fl_Valuator::step() const   */
  proc step: T*int = "$1->step($2);";
  /**    See double Fl_Valuator::step() const   */
  proc step: T*double = "$1->step($2);";
  proc step: T*double*double = "$1->step($2,$3);";
  /**
    Gets or sets the step value. As the user moves the mouse the
    value is rounded to the nearest multiple of the step value. This
    is done <I>before</I> clamping it to the range. For most widgets
    the default step is zero.
    
    <P>For precision the step is stored as the ratio of two
    integers, A/B. You can set these integers directly. Currently
    setting a floating point value sets the nearest A/1 or 1/B value
    possible.
  */
  fun step: T->double = "$1->step()";

  //double step() const {return A/B;}
  fun precision: T->double = "$1->precision($2)";
  proc precision: T*int = "$1->precision($2);";


  /** Gets the floating point(double) value. See int value(double) */
  fun value: T->double = "$1->value()";
  fun value: T*double->int = "$1->value($2)";
  
  gen format: T*string->int = "$1->format(strdup($2.c_str()))";
  fun round: T*double->double = "$1->round($2)";
  fun clamp: T*double->double = "$1->clamp($2)";
  fun increment: T*double->double = "$1->increment($2)";

}

/**
  The Fl_Slider widget contains a sliding knob inside a box. It if
  often used as a scrollbar.  Moving the box all the way to the
  top/left sets it to the minimum(), and to the bottom/right to the
  maximum().  The minimum() may be greater than the maximum() to
  reverse the slider direction.

  Use void Fl_Widget::type(int) to set how the slider is drawn, 
  which can be one of the following:
  
  \li FL_VERTICAL - Draws a vertical slider (this is the default).
  \li FL_HORIZONTAL - Draws a horizontal slider.
  \li FL_VERT_FILL_SLIDER - Draws a filled vertical slider,
      useful as a progress or value meter.
  \li FL_HOR_FILL_SLIDER - Draws a filled horizontal  slider,
      useful as a progress or value meter.
  \li FL_VERT_NICE_SLIDER - Draws a vertical slider with  a nice
      looking control knob.
  \li FL_HOR_NICE_SLIDER - Draws a horizontal slider with  a
      nice looking control knob.

  \image html  slider.png 
  \image latex slider.png "Fl_Slider" width=4cm
*/


class Fl_Slider [T in Fl_Sliders] {
  inherit Fl_Valuator[T];
  inherit Fl_Widget_[T];
  const FL_VERT_SLIDER:utiny;
  const FL_HOR_SLIDER:utiny;
  const FL_VERT_FILL_SLIDER:utiny;
  const FL_HOR_FILL_SLIDER:utiny;
  const FL_VERT_NICE_SLIDER:utiny;
  const FL_HOR_NICE_SLIDER:utiny;
  ctor fl_slider: int*int*int*int*string = "new Fl_Slider($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  ctor fl_slider: int*int*int*int = "new Fl_Slider($1,$2,$3,$4)";
  ctor fl_slider: utiny*int*int*int*int*string = "new Fl_Slider($1,$2,$3,$4,$5,const_cast<char *>(strdup($6.c_str())))";
  ctor fl_slider: utiny*int*int*int*int = "new Fl_Slider($1,$2,$3,$4,$5)";

  fun handle:T*int->int = "$1->handle($2)";
  fun scrollvalue: T*int*int*int*int->int = "$1->scrollvalue($2,$3,$4,$5)";
//  proc bounds: T*double*double = "$1->bounds(double a, double b)";

  /**
    Get the dimensions of the moving piece of slider.
  */
  fun get_slider_size: T->float = "$1->slider_size();";

  /**
    Set the dimensions of the moving piece of slider. This is
    the fraction of the size of the entire widget. If you set this
    to 1 then the slider cannot move.  The default value is .08.

    For the "fill" sliders this is the size of the area around the
    end that causes a drag effect rather than causing the slider to
    jump to the mouse.
  */
  proc slider_size: T*double = "$1->slider_size($2);";


  /** Gets the slider box type. */
  fun get_slider: T->fl_boxtype = "$1->slider()";

  /** Sets the slider box type. */
  proc slider: T*fl_boxtype = "$1->slider($2);";

}
//Fl_Hor_Slider.H
class Fl_Hor_Slider {
  inherit Fl_Widget_[fl_hor_slider];
  //$ Args X,Y,W,H,Opt Label
  ctor fl_hor_slider: int*int*int*int*string = "new Fl_Hor_Slider($1,$2,$3,$4,const_cast<char *>(strdup($5.c_str())))";
  ctor fl_hor_slider: int*int*int*int= "new Fl_Hor_Slider($1,$2,$3,$4)";
}

//fl_draw.H
// Label flags...
//char fl_draw_shortcut;
// Colors:
class Fl_Draw {
/**
 Sets the color for all subsequent drawing operations.
 For colormapped displays, a color cell will be allocated out of
 \p fl_colormap the first time you use a color. If the colormap fills up
 then a least-squares algorithm is used to find the closest color.
 If no valid graphical context (fl_gc) is available,
 the foreground is not set for the current window.
 \param[in] c color 
 */
proc set_fl_color:fl_color = "fl_color($1);";
/** for back compatibility - use fl_color(Fl_Color c) instead */
proc set_fl_color:int = "fl_color($1);";
/**
 Sets the color for all subsequent drawing operations.
 The closest possible match to the RGB color is used.
 The RGB color is used directly on TrueColor displays.
 For colormap visuals the nearest index in the gray
 ramp or color cube is used.
 If no valid graphical context (fl_gc) is available,
 the foreground is not set for the current window.
 \param[in] r,g,b color components
 */
proc set_fl_color:utiny*utiny*utiny = "fl_color($1,$2,$3);";
/**
  Returns the last fl_color() that was set.
  This can be used for state save/restore.
*/
fun getfl_color: 1->fl_color = "fl_color()";

// clip:
/**
 Intersects the current clip region with a rectangle and pushes this
 new region onto the stack.
 \param[in] x,y,w,h position and size
 */
proc fl_push_clip: int*int*int*int = "fl_push_clip($1,$2,$3,$4);";
/**
 Intersects the current clip region with a rectangle and pushes this
 new region onto the stack (deprecated).
 \param[in] x,y,w,h position and size
 \deprecated
   fl_clip(int, int, int, int) is deprecated and will be removed from future releases.
   Please use fl_push_clip(int x, int y, int w, int h) instead.
 */
proc fl_clip: int*int*int*int = "fl_push_clip($1,$2,$3,$4);";
/**
 Pushes an empty clip region onto the stack so nothing will be clipped.
 */
proc fl_push_no_clip: 1 = "fl_push_no_clip();";
/**
 Restores the previous clip region.
 
 You must call fl_pop_clip() once for every time you call fl_push_clip().
 Unpredictable results may occur if the clip stack is not empty when
 you return to FLTK.
 */
proc fl_pop_clip: 1 = "fl_pop_clip();";
/**
 Does the rectangle intersect the current clip region?
 \param[in] x,y,w,h position and size of rectangle
 \returns non-zero if any of the rectangle intersects the current clip
 region. If this returns 0 you don't have to draw the object.
 
 \note
 Under X this returns 2 if the rectangle is partially clipped, 
 and 1 if it is entirely inside the clip region.
 */
fun fl_not_clipped: int*int*int*int->int = "fl_not_clipped($1,$2,$3,$4)";
/**
 Intersects the rectangle with the current clip region and returns the
 bounding box of the result.
 
 Returns non-zero if the resulting rectangle is different to the original.
 This can be used to limit the necessary drawing to a rectangle.
 \p W and \p H are set to zero if the rectangle is completely outside the region.
 \param[in] x,y,w,h position and size of rectangle
 \param[out] X,Y,W,H position and size of resulting bounding box.
 \returns Non-zero if the resulting rectangle is different to the original.
 */
fun fl_clip_box: int*int*int*int->int = "fl_clip_box($1,$2,$3,$4);";

/** Undoes any clobbering of clip done by your program */
proc fl_restore_clip: 1 = "fl_restore_clip();";
/**
 Replaces the top of the clipping stack with a clipping region of any shape.
 
 Fl_Region is an operating system specific type.
 \param[in] r clipping region
 */
proc fl_clip_region: fl_region = "fl_clip_region($1);";
/**
 Returns the current clipping region.
 */
fun get_fl_clip_region: 1->fl_region = "fl_clip_region()";


// points:
/**
 Draws a single pixel at the given coordinates
 */
proc fl_point: int*int = "fl_point($1,$2);";

// line type:
/**
 Sets how to draw lines (the "pen").
 If you change this it is your responsibility to set it back to the default
 using \c fl_line_style(0).
 
 \param[in] style A bitmask which is a bitwise-OR of a line style, a cap
 style, and a join style. If you don't specify a dash type you
 will get a solid line. If you don't specify a cap or join type
 you will get a system-defined default of whatever value is
 fastest.
 \param[in] width The thickness of the lines in pixels. Zero results in the
 system defined default, which on both X and Windows is somewhat
 different and nicer than 1.
 \param[in] dashes A pointer to an array of dash lengths, measured in pixels.
 The first location is how long to draw a solid portion, the next
 is how long to draw the gap, then the solid, etc. It is terminated
 with a zero-length entry. A \c NULL pointer or a zero-length
 array results in a solid line. Odd array sizes are not supported
 and result in undefined behavior.
 
 \note      Because of how line styles are implemented on Win32 systems,
 you \e must set the line style \e after setting the drawing
 color. If you set the color after the line style you will lose
 the line style settings.
 \note      The \p dashes array does not work under Windows 95, 98 or Me,
 since those operating systems do not support complex line styles.
 */
proc fl_line_style: fl_line_styles*int*int*char = "fl_line_style($1,$2,$3);";
proc fl_line_style: fl_line_styles*int*int = "fl_line_style($1,$2);";
proc fl_line_style: fl_line_styles*int = "fl_line_style($1);";

cflags fl_line_styles=
  FL_SOLID,			///< line style: <tt>___________</tt>
  FL_DASH,		///< line style: <tt>_ _ _ _ _ _</tt>
  FL_DOT,		///< line style: <tt>. . . . . .</tt>
  FL_DASHDOT,		///< line style: <tt>_ . _ . _ .</tt>
  FL_DASHDOTDOT,		///< line style: <tt>_ . . _ . .</tt>

  FL_CAP_FLAT,	///< cap style: end is flat
  FL_CAP_ROUND,	///< cap style: end is round
  FL_CAP_SQUARE,	///< cap style: end wraps end point

  FL_JOIN_MITER,	///< join style: line join extends to a point
  FL_JOIN_ROUND,	///< join style: line join is rounded
  FL_JOIN_BEVEL;	///< join style: line join is tidied


// rectangles tweaked to exactly fill the pixel rectangle:

/** 
 Draws a 1-pixel border \e inside the given bounding box.
 This function is meant for quick drawing of simple boxes. The behavior is 
 undefined for line widths that are not 1.
 */
proc fl_rect: int*int*int*int = "fl_rect($1,$2,$3,$4);";

/** Draws with passed color a 1-pixel border \e inside the given bounding box */
proc fl_rect: int*int*int*int*fl_color = "fl_rect($1,$2,$3,$4,$5);";

/** Colors with current color a rectangle that exactly fills the given bounding box */
proc fl_rectf: int*int*int*int = "fl_rectf($1,$2,$3,$4);";

/** Colors with passed color a rectangle that exactly fills the given bounding box */
proc fl_rectf: int*int*int*int*fl_color = "fl_rectf($1,$2,$3,$4,$5);";

/**
  Colors a rectangle with "exactly" the passed <tt>r,g,b</tt> color.
  On screens with less than 24 bits of color this is done by drawing a
  solid-colored block using fl_draw_image() so that the correct color
  shade is produced.
  */
/* note: doxygen comment here to avoid triplication in os-speciic files */
//FL_EXPORT void fl_rectf(int x, int y, int w, int h, utiny r, utiny g, utiny b);

// line segments:
/**
 Draws a line from (x,y) to (x1,y1)
 */
proc fl_line: int*int*int*int = "fl_line($1,$2,$3,$4);";

/**
 Draws a line from (x,y) to (x1,y1) and another from (x1,y1) to (x2,y2)
 */
proc fl_line: int*int*int*int*int*int*int*int;


// closed line segments:
/**
 Outlines a 3-sided polygon with lines
 */
proc fl_loop: int*int*int*int*int*int*int*int;

/**
 Outlines a 4-sided polygon with lines
 */
proc fl_loop: int*int*int*int*int*int*int*int*int*int;


// filled polygons
/**
 Fills a 3-sided polygon. The polygon must be convex.
 */
proc fl_polygon: int*int*int*int*int*int*int*int;

/**
 Fills a 4-sided polygon. The polygon must be convex.
 */
proc fl_polygon: int*int*int*int*int*int*int*int*int*int;

// draw rectilinear lines, horizontal segment first:
/**
 Draws a horizontal line from (x,y) to (x1,y)
 */
proc fl_xyline: int*int*int;

/**
 Draws a horizontal line from (x,y) to (x1,y), then vertical from (x1,y) to (x1,y2)
 */
proc fl_xyline: int*int*int*int;

/**
 Draws a horizontal line from (x,y) to (x1,y), then a vertical from (x1,y) to (x1,y2)
 and then another horizontal from (x1,y2) to (x3,y2)
 */
proc fl_xyline: int*int*int*int*int;

// draw rectilinear lines, vertical segment first:
/**
 Draws a vertical line from (x,y) to (x,y1)
 */
proc fl_yxline: int*int*int;

/**
 Draws a vertical line from (x,y) to (x,y1), then a horizontal from (x,y1) to (x2,y1)
 */
proc fl_yxline: int*int*int*int;

/**
 Draws a vertical line from (x,y) to (x,y1) then a horizontal from (x,y1)
 to (x2,y1), then another vertical from (x2,y1) to (x2,y3)
 */
proc fl_yxline: int*int*int*int*int;

// circular lines and pie slices (code in fl_arci.C):
/**
 Draw ellipse sections using integer coordinates.
 
 These functions match the rather limited circle drawing code provided by X
 and WIN32. The advantage over using fl_arc with floating point coordinates
 is that they are faster because they often use the hardware, and they draw
 much nicer small circles, since the small sizes are often hard-coded bitmaps.
 
 If a complete circle is drawn it will fit inside the passed bounding box.
 The two angles are measured in degrees counter-clockwise from 3 o'clock and
 are the starting and ending angle of the arc, \p a2 must be greater or equal
 to \p a1.
 
 fl_arc() draws a series of lines to approximate the arc. Notice that the
 integer version of fl_arc() has a different number of arguments than the
 double version fl_arc(double x, double y, double r, double start, double end)
 
 \param[in] x,y,w,h bounding box of complete circle
 \param[in] a1,a2 start and end angles of arc measured in degrees
 counter-clockwise from 3 o'clock. \p a2 must be greater
 than or equal to \p a1.
 */
proc fl_arc: int*int*int*int*double*double;

/**
 Draw filled ellipse sections using integer coordinates.
 
 Like fl_arc(), but fl_pie() draws a filled-in pie slice.
 This slice may extend outside the line drawn by fl_arc();
 to avoid this use w - 1 and h - 1.
 
 \param[in] x,y,w,h bounding box of complete circle
 \param[in] a1,a2 start and end angles of arc measured in degrees
 counter-clockwise from 3 o'clock. \p a2 must be greater
 than or equal to \p a1.
 */
proc fl_pie: int*int*int*int*double*double;

/** fl_chord declaration is a place holder - the function does not yet exist */
//FL_EXPORT void fl_chord(int x, int y, int w, int h, double a1, double a2); // nyi

// scalable drawing code (code in fl_vertex.C and fl_arc.C):
/**
 Saves the current transformation matrix on the stack. 
 The maximum depth of the stack is 32.
 */
proc fl_push_matrix:1;
/**
 Restores the current transformation matrix from the stack.
 */
proc fl_pop_matrix:1;
/**
 Concatenates scaling transformation onto the current one.
 \param[in] x,y scale factors in x-direction and y-direction
 */
proc fl_scale:double*double;
/**
 Concatenates scaling transformation onto the current one.
 \param[in] x scale factor in both x-direction and y-direction
 */
proc fl_scale:double;
/**
 Concatenates translation transformation onto the current one.
 \param[in] x,y translation factor in x-direction and y-direction
 */
proc fl_translate:double*double;
/**
 Concatenates rotation transformation onto the current one.
 \param[in] d - rotation angle, counter-clockwise in degrees (not radians)
 */
proc fl_rotate:double;
/**
 Concatenates another transformation onto the current one.
 
 \param[in] a,b,c,d,x,y transformation matrix elements such that
 <tt> X' = aX + cY + x </tt> and <tt> Y' = bX +dY + y </tt>
 */
proc fl_mult_matrix: double*double*double*double*double*double;

/**
 Starts drawing a list of points. Points are added to the list with fl_vertex()
 */
proc fl_begin_points:1;
/**
 Starts drawing a list of lines.
 */
proc fl_begin_line:1;
/**
 Starts drawing a closed sequence of lines.
 */
proc fl_begin_loop:1;
/**
 Starts drawing a convex filled polygon.
 */
proc fl_begin_polygon:1;
/**
 Adds a single vertex to the current path.
 \param[in] x,y coordinate
 */
proc fl_vertex:double*double;
/**
 Adds a series of points on a Bezier curve to the path.
 The curve ends (and two of the points) are at X0,Y0 and X3,Y3.
 \param[in] X0,Y0 curve start point
 \param[in] X1,Y1 curve control point
 \param[in] X2,Y2 curve control point
 \param[in] X3,Y3 curve end point
 */
proc fl_curve:double*double*double*double*double*double*double*double;
  
/**
 Adds a series of points to the current path on the arc of a circle.
 You can get elliptical paths by using scale and rotate before calling fl_arc().
 \param[in] x,y,r center and radius of circular arc
 \param[in] start,end angles of start and end of arc measured in degrees
 counter-clockwise from 3 o'clock. If \p end is less than \p start
 then it draws the arc in a clockwise direction.
 */
proc fl_arc:double*double*double*double*double;
/**
 fl_circle() is equivalent to fl_arc(x,y,r,0,360), but may be faster.
 
 It must be the \e only thing in the path: if you want a circle as part of
 a complex polygon you must use fl_arc()
 \param[in] x,y,r center and radius of circle
 */
proc fl_circle: double*double*double;
/**
 Ends list of points, and draws.
 */
proc fl_end_points: 1;
/**
 Ends list of lines, and draws.
 */
proc fl_end_line: 1;
/**
 Ends closed sequence of lines, and draws.
 */
proc fl_end_loop: 1;
/**
 Ends convex filled polygon, and draws.
 */
proc fl_end_polygon: 1;
/**
 Starts drawing a complex filled polygon.
 
 The polygon may be concave, may have holes in it, or may be several
 disconnected pieces. Call fl_gap() to separate loops of the path.
 
 To outline the polygon, use fl_begin_loop() and replace each fl_gap()
 with fl_end_loop();fl_begin_loop() pairs.
 
 \note
 For portability, you should only draw polygons that appear the same
 whether "even/odd" or "non-zero" winding rules are used to fill them.
 Holes should be drawn in the opposite direction to the outside loop.
 */
proc fl_begin_complex_polygon: 1;
/**
 Call fl_gap() to separate loops of the path.
 
 It is unnecessary but harmless to call fl_gap() before the first vertex,
 after the last vertex, or several times in a row.
 */
proc fl_gap: 1;
/**
 Ends complex filled polygon, and draws.
 */
proc fl_end_complex_polygon: 1;
// get and use transformed positions:
/**
 Transforms coordinate using the current transformation matrix.
 \param[in] x,y coordinate
 */
fun fl_transform_x: double*double->double;
/**
 Transforms coordinate using the current transformation matrix.
 \param[in] x,y coordinate
 */
fun fl_transform_y: double*double->double;

/**
 Transforms distance using current transformation matrix.
 \param[in] x,y coordinate
 */
fun fl_transform_dx: double*double->double;

/**
 Transforms distance using current transformation matrix.
 \param[in] x,y coordinate
 */
fun fl_transform_dy: double*double->double;
/**
 Adds coordinate pair to the vertex list without further transformations.
 \param[in] xf,yf transformed coordinate
 */
proc fl_transformed_vertex: double*double;

// Fonts:
/**
  Sets the current font, which is then used in various drawing routines.
  You may call this outside a draw context if necessary to call fl_width(),
  but on X this will open the display.

  The font is identified by a \p face and a \p size.
  The size of the font is measured in pixels and not "points".
  Lines should be spaced \p size pixels apart or more.
*/
proc get_fl_font:fl_font*fl_fontsize;

/**
  Returns the \p face set by the most recent call to fl_font().
  This can be used to save/restore the font.
*/
fun get_fl_font: 1->fl_font;
/**
  Returns the \p size set by the most recent call to fl_font().
  This can be used to save/restore the font.
*/
fun fl_size: 1->fl_fontsize;

// information you can get about the current font:
/**
  Returns the recommended minimum line spacing for the current font.
  You can also use the value of \p size passed to fl_font()
*/
fun fl_height: 1->int;
fun fl_height: int*int->int;

/**
  Returns the recommended distance above the bottom of a fl_height() tall box to
  draw the text at so it looks centered vertically in that box.
*/
fun fl_descent: 1->int;
/** Returns the typographical width of a nul-terminated string */
fun fl_width: string->double = "fl_width(const_cast<char *>(strdup($1.c_str())))";
/** Returns the typographical width of a sequence of \p n characters */
fun fl_width: string*int->double = "fl_width(const_cast<char *>(strdup($1.c_str())),$2)";
/** Returns the typographical width of a single character.
    \note if a valid fl_gc is NOT found then it uses the first window gc,
    or the screen gc if no fltk window is available when called. */
fun fl_width:uint->double = "fl_width($1)";

/** Determines the minimum pixel dimensions of a nul-terminated string.

  Usage: given a string "txt" drawn using fl_draw(txt, x, y) you would determine
  its pixel extents on the display using fl_text_extents(txt, dx, dy, wo, ho)
  such that a bounding box that exactly fits around the text could be drawn with
  fl_rect(x+dx, y+dy, wo, ho). Note the dx, dy values hold the offset of the first
  "colored in" pixel of the string, from the draw origin.
*/
proc fl_text_extents: string*&int*&int*&int*&int = "fl_text_extents(const_cast<char *>(strdup($1.c_str(), $1, $2, $3, $4);"; // NO fltk symbol expansion will be performed
/** Determines the minimum pixel dimensions of a sequence of \p n characters.
\see fl_text_extents(const char*, int& dx, int& dy, int& w, int& h)
*/
proc fl_text_extents: string*int*&int*&int*&int*&int = "fl_text_extents(const_cast<char *>(strdup($1.c_str(), $1, $2, $3, $4,$5);"; 

// font encoding:
// Note: doxygen comments here to avoid duplication for os-sepecific cases
/**
  Converts text from Windows/X11 latin1 character set to local encoding.
  \param[in] t character string (latin1 encoding)
  \param[in] n optional number of characters to convert (default is all)
  \returns pointer to internal buffer containing converted characters
  */
fun fl_latin1_to_local:string*int->string = "fl_latin1_to_local(const_cast<char *>(strdup($1.c_str())),$1)";
fun fl_latin1_to_local:string->string = "fl_latin1_to_local(const_cast<char *>(strdup($1.c_str())))";
/**
  Converts text from local encoding to Windowx/X11 latin1 character set.
  \param[in] t character string (local encoding)
  \param[in] n optional number of characters to convert (default is all)
  \returns pointer to internal buffer containing converted characters
  */
fun fl_local_to_latin1:string*int->string = "fl_local_to_latin1(const_cast<char *>(strdup($1.c_str())),$1)";

/**
  Converts text from Mac Roman character set to local encoding.
  \param[in] t character string (Mac Roman encoding)
  \param[in] n optional number of characters to convert (default is all)
  \returns pointer to internal buffer containing converted characters
  */
fun fl_mac_to_local:string*int->string = "fl_mac_to_local(const_cast<char *>(strdup($1.c_str())),$1)";

/**
  Converts text from local encoding to Mac Roman character set.
  \param[in] t character string (local encoding)
  \param[in] n optional number of characters to convert (default is all)
  \returns pointer to internal buffer containing converted characters
  */
fun fl_local_to_mac_roman:string*int->string = "fl_local_to_mac_roman(const_cast<char *>(strdup($1.c_str())),$1)";

/**
  Draws a nul-terminated string starting at the given location.

  Text is aligned to the left and to the baseline of the font.
  To align to the bottom, subtract fl_descent() from \p y.
  To align to the top, subtract fl_descent() and add fl_height().
  This version of fl_draw provides direct access to the text drawing
  function of the underlying OS. It does not apply any special handling
  to control characters.
*/
proc fl_draw:string*int*int = "fl_draw(const_cast<char *>(strdup($1.c_str())),$2,$3);";
/**
  Draws a nul-terminated string starting at the given location and 
  rotating \p angle degrees counter-clockwise.
  This version of fl_draw provides direct access to the text drawing
  function of the underlying OS and is supported by Xft, Win32 and MacOS
  fltk subsets.
*/
proc fl_draw:int*string*int*int = "fl_draw($1,const_cast<char *>(strdup($2.c_str())),$3,$4);";

/**
  Draws an array of \p n characters starting at the given location.
*/
proc fl_draw:string*int*int*int = "fl_draw(const_cast<char *>(strdup($1.c_str())),$2,$3,$4);";

/**
  Draws an array of \p n characters starting at the given location,
  rotating \p angle degrees counter-clockwise.
*/
proc fl_draw:int*string*int*int*int = "fl_draw($1,const_cast<char *>(strdup($2.c_str())),$3,$4,$5);";

/**
  Draws an array of \p n characters right to left starting at given location.
*/
proc fl_rtl_draw:string*int*int*int = "fl_rtl_draw(const_cast<char *>(strdup($1.c_str())),$2,$3,$4);";
proc fl_measure:string*&int*&int*int = "fl_measure(const_cast<char *>(strdup($1.c_str())),$2,$3,$4);";
proc fl_measure:string*&int*&int = "fl_measure(const_cast<char *>(strdup($1.c_str())),$2,$3);";
proc fl_draw:string*int*int*int*int*fl_align*fl_image*int = "fl_draw(const_cast<char *>(strdup($1.c_str())),$2,$3,$4,$5,$6,$7,$8);";
proc fl_draw:string*int*int*int*int*fl_align*fl_image = "fl_draw(const_cast<char *>(strdup($1.c_str())),$2,$3,$4,$5,$6,$7);";
typedef callthis = +char*int*int*int-->address;
proc fl_draw:string*int*int*int*int*fl_align*callthis*fl_image*int = "fl_draw(const_cast<char *>(strdup($1.c_str())),$2,$3,$4,$5,$6,$7,$8);";
proc fl_draw:string*int*int*int*int*fl_align*callthis*fl_image = "fl_draw(const_cast<char *>(strdup($1.c_str())),$2,$3,$4,$5,$6,$7);";

// boxtypes:
proc fl_frame:string*int*int*int*int = "fl_frame(const_cast<char *>(strdup($1.c_str())),$2,$3,$4,$5);";
proc fl_frame2:string*int*int*int*int = "fl_frame2(const_cast<char *>(strdup($1.c_str())),$2,$3,$4,$5);";
proc fl_draw_box:string*int*int*int*int*fl_color = "fl_draw_box(const_cast<char *>(strdup($1.c_str())),$2,$3,$4,$5,$6);";

// images:

/**
  Draws an 8-bit per color RGB or luminance image.
  \param[in] buf points at the "r" data of the top-left pixel.
                 Color data must be in <tt>r,g,b</tt> order.
		 Luminance data is only one <tt>gray</tt> byte.
  \param[in] X,Y position where to put top-left corner of image
  \param[in] W,H size of the image
  \param[in] D   delta to add to the pointer between pixels. It may be
                 any value greater than or equal to 1, or it can be
		 negative to flip the image horizontally
  \param[in] L   delta to add to the pointer between lines (if 0 is
                 passed it uses \p W * \p D), and may be larger than
		 \p W * \p D to crop data, or negative to flip the
		 image vertically

  It is highly recommended that you put the following code before the
  first <tt>show()</tt> of \e any window in your program to get rid of
  the dithering if possible:
  \code
  Fl::visual(FL_RGB);
  \endcode

  Gray scale (1-channel) images may be drawn. This is done if
  <tt>abs(D)</tt> is less than 3, or by calling fl_draw_image_mono().
  Only one 8-bit sample is used for each pixel, and on screens with
  different numbers of bits for red, green, and blue only gray colors
  are used. Setting \p D greater than 1 will let you display one channel
  of a color image.

  \par Note:
  The X version does not support all possible visuals. If FLTK cannot
  draw the image in the current visual it will abort. FLTK supports
  any visual of 8 bits or less, and all common TrueColor visuals up
  to 32 bits.
  */
proc fl_draw_image: +utiny*int*int*int*int*int*int;
proc fl_draw_image: +utiny*int*int*int*int*int;
proc fl_draw_image: +utiny*int*int*int*int;

/**
  Draws a gray-scale (1 channel) image.
  \see fl_draw_image(const utiny* buf, int X,int Y,int W,int H, int D, int L)
  */
proc fl_draw_image_mono: +utiny*int*int*int*int*int*int;
proc fl_draw_image_mono: +utiny*int*int*int*int*int;
proc fl_draw_image_mono: +utiny*int*int*int*int;

/**
  Draws an image using a callback function to generate image data.

  You can generate the image as it is being drawn, or do arbitrary
  decompression of stored data, provided it can be decompressed to
  individual scan lines easily.
  \param[in] cb   callback function to generate scan line data
  \param[in] data user data passed to callback function
  \param[in] X,Y  screen position of top left pixel
  \param[in] W,H  image width and height
  \param[in] D    data size in bytes (must be greater than 0)
  \see fl_draw_image(const uchar* buf, int X,int Y,int W,int H, int D, int L)

  The callback function \p cb is called with the <tt>void*</tt> \p data
  user data pointer to allow access to a structure of information about
  the image, and the \p x, \p y, and \p w of the scan line desired from
  the image. 0,0 is the upper-left corner of the image, not \p x, \p y.
  A pointer to a buffer to put the data into is passed. You must copy
  \p w pixels from scanline \p y, starting at pixel \p x, to this buffer.

  Due to cropping, less than the whole image may be requested. So \p x
  may be greater than zero, the first \p y may be greater than zero,
  and \p w may be less than \p W. The buffer is long enough to store
  the entire \p W * \p D pixels, this is for convenience with some
  decompression schemes where you must decompress the entire line at
  once: decompress it into the buffer, and then if \p x is not zero,
  copy the data over so the \p x'th pixel is at the start of the buffer.

  You can assume the \p y's will be consecutive, except the first one
  may be greater than zero.

  If \p D is 4 or more, you must fill in the unused bytes with zero.
  */
proc fl_draw_image: +utiny*int*int*int*int*int*int;


typedef fl_draw_image_cb = address*int*int*int*+utiny-->void;
proc fl_draw_image: fl_draw_image_cb*address*int*int*int*int*int;

proc fl_draw_image: fl_draw_image_cb*address*int*int*int*int;

/**
  Draws a gray-scale image using a callback function to generate image data.
  \see fl_draw_image(Fl_Draw_Image_Cb cb, void* data, int X,int Y,int W,int H, int D)
  */
proc fl_draw_image: fl_draw_image_cb*address*int*int*int*int*int;
proc fl_draw_image: fl_draw_image_cb*address*int*int*int*int;

/**
  Checks whether platform supports true alpha blending for RGBA images.
  \returns 1 if true alpha blending supported by platform
  \returns 0 not supported so FLTK will use screen door transparency
  */
/* note: doxygen comment here to avoid triplication in os-speciic files */
fun fl_can_do_alpha_blending: 1 -> char;

/**
  Reads an RGB(A) image from the current window or off-screen buffer.
  \param[in] p     pixel buffer, or NULL to allocate one
  \param[in] X,Y   position of top-left of image to read
  \param[in] W,H   width and height of image to read
  \param[in] alpha alpha value for image (0 for none)
  \returns pointer to pixel buffer, or NULL if allocation failed.

  The \p p argument points to a buffer that can hold the image and must
  be at least \p W*H*3 bytes when reading RGB images, or \p W*H*4 bytes
  when reading RGBA images. If NULL, fl_read_image() will create an
  array of the proper size which can be freed using <tt>delete[]</tt>.

  The \p alpha parameter controls whether an alpha channel is created
  and the value that is placed in the alpha channel. If 0, no alpha
  channel is generated.
  */
/* note: doxygen comment here to avoid triplication in os-speciic files */

fun fl_read_image: +utiny*int*int*int*int*int -> +utiny;
fun fl_read_image: +utiny*int*int*int*int -> utiny;

// pixmaps:
//FL_EXPORT int fl_draw_pixmap(/*const*/ char* const* data, int x,int y,Fl_Color=FL_GRAY);
//FL_EXPORT int fl_draw_pixmap(const char* const* cdata, int x,int y,Fl_Color=FL_GRAY);
//FL_EXPORT int fl_measure_pixmap(/*const*/ char* const* data, int &w, int &h);
//FL_EXPORT int fl_measure_pixmap(const char* const* cdata, int &w, int &h);

// other:
proc fl_scroll: int*int*int*int*int*int;
fun fl_shortcut_label:uint->string;
fun fl_shortcut_label(v:int):string => fl_shortcut_label(cast[uint](v));
//FL_EXPORT const char* fl_shortcut_label(unsigned int shortcut);
fun fl_shortcut_label:uint*carray[char]->string;
fun fl_shortcut_label:int*carray[char]->string = "fl_shortcut_label((unsigned)$1,$2)";
//FL_EXPORT const char* fl_shortcut_label(unsigned int shortcut, const char **eom);
fun fl_old_shortcut:string->uint = "fl_old_shortcut(const_cast<char *>(strdup($1.c_str())))";
proc fl_overlay_rect:int*int*int*int;
proc fl_overlay_clear: 1;
proc set_fl_cursor: fl_cursor*fl_color*fl_color;
proc set_fl_cursor: fl_cursor*fl_color;
proc set_fl_cursor: fl_cursor;
fun fl_expand_text:string*+char*int*double*&int*&double*int*int->string = "fl_expand_text(const_cast<char *>(strdup($1.c_str())),$2,$3,$4,$5,$6)";




// XIM:
/** \todo provide user documentation for fl_set_status function */
//FL_EXPORT void fl_set_status(int X, int Y, int W, int H);
/** \todo provide user documentation for fl_set_spot function */
//FL_EXPORT void fl_set_spot(int font, int size, int X, int Y, int W, int H, Fl_Window *win=0);
/** \todo provide user documentation for fl_reset_spot function*/
//FL_EXPORT void fl_reset_spot(void);
// XForms symbols:
//FL_EXPORT int fl_draw_symbol(const char* label,int x,int y,int w,int h, Fl_Color);
//FL_EXPORT int fl_add_symbol(const char* name, void (*drawit)(Fl_Color), int scalable);

}